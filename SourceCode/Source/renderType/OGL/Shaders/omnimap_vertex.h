static char effectomnimap_vertex[] = { 
"//#ifdef STENCILMASK_ENABLE\n" 
"varying vec2 PixelPos;\n" 
"//#endif\n" 
"//JT\n" 
"varying vec3 VertexPosition_WorldSpace;\n" 
"varying float R;\n" 
"/*\n" 
"to do\n" 
"check if MyPI is allready defined\n" 
"look at assembly code...\n" 
"skip computing  xyRadius\n" 
"optimize the const vars\n" 
"*/\n" 
"void main()\n" 
"{\n" 
"// vertex shader has two goals...\n" 
"// (1) pass worldspace coordinates to fragment shader\n" 
"// (2) set projector space coordinates as gl position\n" 
"// (2a) orthographic projection\n" 
"// (2b) ftheta projection\n" 
"// (2c) Normal Projector\n" 
"// (1)\n" 
"	VertexPosition_WorldSpace.xyz = gl_Vertex.xyz;\n" 
"//	gl_Position = ftransform();	//Position of vertex in projector space\n" 
"	if(false)// (2) a\n" 
"	{	\n" 
"		gl_Position = ftransform();	//Position of vertex in projector space\n" 
"		R = gl_Position.w;\n" 
"		gl_Position.w = 1.0;\n" 
"		gl_TexCoord[0] = (gl_TextureMatrix[0]) * gl_Vertex;\n" 
"		gl_TexCoord[1] = (gl_TextureMatrix[1]) * gl_Vertex;\n" 
"		gl_TexCoord[2] = (gl_TextureMatrix[2]) * gl_Vertex;\n" 
"		gl_TexCoord[3] = (gl_TextureMatrix[3]) * gl_Vertex;\n" 
"		//gl_TexCoord[4] = (gl_TextureMatrix[4]) * gl_Vertex;\n" 
"		//gl_TexCoord[5] = (gl_TextureMatrix[5]) * gl_Vertex;\n" 
"	}\n" 
"	else// (2) b\n" 
"	{\n" 
"		vec4 VertexPosition_projectorSpace_Goal = ftransform();\n" 
"		// F-Theta Warping Code\n" 
"		float Z = VertexPosition_projectorSpace_Goal.z;\n" 
"		float D = length(VertexPosition_projectorSpace_Goal.xyz);\n" 
"		float MyPI = 3.14159265;  \n" 
"		R = (2.0/MyPI) * acos(Z/D);  // Ftheta.\n" 
"	\n" 
"	\n" 
"		/// this line is for converting the ftheta lenses image to !theta image\n" 
"		// if(usebangtheta)\n" 
"		R =  0.2798*R *R *R *R *R *R  - 0.6875*R *R *R *R *R  + 0.7351*R *R *R *R  - 0.3472*R *R *R  + 0.0977*R *R  + 0.9221*R ;  \n" 
" \n" 
"	\n" 
"		float l =1.0/ (length(VertexPosition_projectorSpace_Goal.xy)+.0000000000000000000000000000000000001);// bug fix  1\n" 
"		vec2 thetavec = VertexPosition_projectorSpace_Goal.xy *vec2(l,l); // bug fix  1\n" 
"		\n" 
"		//float2 thetavec =normalize(VertexPosition_projectorSpace_Goal.xy);  // orginial 1\n" 
"		// gl_position is VertexPosition_projectorSpace_OpiticalDistort_precorrect\n" 
"		\n" 
"		\n" 
"	\n" 
"		\n" 
"		gl_Position.xy= thetavec * R;\n" 
"		gl_Position.w =1.0;\n" 
"		gl_Position.z =-D/1000.0;   // bug fix 2b fix for reverse z depth\n" 
"		// R > 1.0 for verticies behind the lens.  R will approach inf as it becomes exactly behind the lens.\n" 
"		// Use this trick to discard triangles that can potentially be directly behind the lens.\n" 
"		if(R > 2.0)\n" 
"			gl_Position.z =-100000.0;\n" 
"		gl_TexCoord[0] = (gl_TextureMatrix[0]) * gl_Vertex;\n" 
"		gl_TexCoord[1] = (gl_TextureMatrix[1]) * gl_Vertex;\n" 
"		gl_TexCoord[2] = (gl_TextureMatrix[2]) * gl_Vertex;\n" 
"		gl_TexCoord[3] = (gl_TextureMatrix[3]) * gl_Vertex;\n" 
"		//gl_TexCoord[4] = (gl_TextureMatrix[4]) * gl_Vertex;\n" 
"		//gl_TexCoord[5] = (gl_TextureMatrix[5]) * gl_Vertex;\n" 
"}\n" 
"PixelPos.xy = gl_Position.xy * vec2(.5,-.5) + vec2(.5 , .5);//+ \n" 
"}\n" 
}; 
