// OmniMap Geometry Correction Libs
// (c)2006, 2007, 2010 Elumenati

//#include "Socket.h"  // need socket.cpp socket.h and the lib file
#define MIRROR_BALL 1
#include <string>
#include <vector>
#include "omnimap.h"
#include <assert.h>
#include <math.h>

#include "tools/GLShader.h"
#include "tools/RenderChannel.h"
#include "privatePrimitives.h"
// JTCHANGE: need defn. of SAVE_AFTER_EVERY_MESSAGE
#include "omnimap_luatable.h"
#include "ScreenRendererOGL.h"

#include "omnitypedefs.h"
#include "OM_ErrorHandling.h"

extern unsigned int logow;
extern unsigned int logoh;
extern char logoDataGL[];

#ifdef USE_DOMEVIEW
#include "../IPC_Domeview/IPCDomeView.h"
static int ApplicationCode;

static HINSTANCE instance = NULL;
static IPCDomeView *domeViewIPC = NULL;
#endif







OMNIMAP_UNMANAGEDGLUE_API OmniMap *UnmanagedGlue_OmnimapConstructorOGL(int _resW, int _resH, const char *strStartUpScriptFile, const char *luaResDir);
OMNIMAP_UNMANAGEDGLUE_API void UnmanagedGlue_OmnimapDestructorOGL(OmniMap *omnimapHandle);
OMNIMAP_UNMANAGEDGLUE_API int UnmanagedGlue_OmnimapGetChannelTotalOGL(OmniMap *omnimapHandle);
OMNIMAP_UNMANAGEDGLUE_API OmniMap_Channel *UnmanagedGlue_OmnimapGetChannelInfoOGL(OmniMap *omnimapHandle, int channelNumber, float viewMatrix[16], float projectionMatrix[16]);
OMNIMAP_UNMANAGEDGLUE_API void UnmanagedGlue_OmnimapBeginRenderChannelOGL(OmniMap_Channel *channelHandle);
OMNIMAP_UNMANAGEDGLUE_API void UnmanagedGlue_OmnimapEndRenderChannelOGL(OmniMap_Channel*channelHandle);
OMNIMAP_UNMANAGEDGLUE_API void UnmanagedGlue_OmnimapPostRenderOGL(OmniMap *omnimapHandle);


OMNIMAP_UNMANAGEDGLUE_API OmniMap *UnmanagedGlue_OmnimapConstructorOGL(int _resW, int _resH, const char *strStartUpScriptFile, const char *luaResDir) {
  const char *strStartUpScriptFileBase = (strStartUpScriptFile) ? strStartUpScriptFile : "Resources/omnimap_startup.lua";
  const char *luaResDirBase = (luaResDir) ? luaResDir : "Resources/";
  return new OmniMap(_resW, _resH, strStartUpScriptFileBase, luaResDirBase);
}


OMNIMAP_UNMANAGEDGLUE_API void UnmanagedGlue_OmnimapDestructorOGL(OmniMap *omnimapHandle) {
  delete omnimapHandle;
}


OMNIMAP_UNMANAGEDGLUE_API int UnmanagedGlue_OmnimapGetChannelTotalOGL(OmniMap *omnimapHandle) {
  return omnimapHandle->GetNumChannels();
}

OMNIMAP_UNMANAGEDGLUE_API OmniMap_Channel *UnmanagedGlue_OmnimapGetChannelInfoOGL(OmniMap *omnimapHandle, int channelNumber, float viewMatrix[16], float projectionMatrix[16]) {
  OmniMap_Channel*channel = (OmniMap_Channel *)omnimapHandle->GetChannel(channelNumber);

  if (viewMatrix) {
    channel->GetViewMatrix(viewMatrix);
  }
  if (projectionMatrix) {
    channel->GetProjectionMatrix(projectionMatrix);
  }

  return channel;
}

OMNIMAP_UNMANAGEDGLUE_API void UnmanagedGlue_OmnimapBeginRenderChannelOGL(OmniMap_Channel *channelHandle) {
  channelHandle->beginRenderToChannel();
}

OMNIMAP_UNMANAGEDGLUE_API void UnmanagedGlue_OmnimapEndRenderChannelOGL(OmniMap_Channel *channelHandle) {
  channelHandle->endRenderToChannel();
}

OMNIMAP_UNMANAGEDGLUE_API void UnmanagedGlue_OmnimapPostRenderOGL(OmniMap *omnimapHandle) {
  omnimapHandle->PostRender();
}





///////////////////////////////////////////////


#define EH_GL_ASSERT(STR) \
  EH_Zero(checkGLError()); \
  assert(checkGLError() && STR);


extern std::string preprocessorMacroGlobal;


/////// extern spout ////////////////////
extern bool useSpoutInRenderChannels;
extern OmniSpout *omniSpout;
extern bool useSpoutInFinalPassCamera;
/////////////////////////////////////////////////

int OmniMap_getGL_TEXTUREN_ARB_From_N(int n);


static const char *fragShaderPrelude = 
"// Start Header: automatically generated by Omnimap\n\
#define MaxChannels %d\n\
float MirrorRadius = %f;\n\
float Grace = %f;\n\
vec3 MirrorCenter = vec3(%f,%f,%f);\n\
vec3 AudiencePosition = vec3(%f,%f,%f);\n\
vec3 ProjectorOrigin= vec3(%f,%f,%f);\n\
vec3 ProjectorRayUp = vec3(%f,%f,%f);\n\
\n%s\n// End Header\n\n";








#ifdef USE_DOMEVIEW
static bool FileExist (char * fileName)
{
  FILE * infile = fopen (fileName, "r");
  if (infile != NULL)
  {
    fclose (infile); // if you don't close, you get in trouble..
    return true;
  }
  return false;
}
#endif



int OmniMap_getGL_TEXTUREN_ARB_From_N(int n)
{
	switch(n)
	{
		case 0: return GL_TEXTURE0_ARB;break;
		case 1: return GL_TEXTURE1_ARB;break;
		case 2: return GL_TEXTURE2_ARB;break;
		case 3: return GL_TEXTURE3_ARB;break;
		case 4: return GL_TEXTURE4_ARB;break;
		case 5: return GL_TEXTURE5_ARB;break;
		case 6: return GL_TEXTURE6_ARB;break;
		case 7: return GL_TEXTURE7_ARB;break;
		case 8: return GL_TEXTURE8_ARB;break;
		case 9: return GL_TEXTURE9_ARB;break;
	}
	assert(0 && "Error! getNumberFromGL_TEXTUREID_ARB");
	return GL_TEXTURE0_ARB;
}





///////////////////////////////////////////////////////////
////////
////////////////////////////////////////////////////////////





OmniMap::OmniMap(int _resW, int _resH,const char* strStartUpScriptFile, const char *luaResDir, bool doInit) :
OmniMapBase(_resW, _resH, strStartUpScriptFile, luaResDir)
{
  EH_DECLARE;
  EH_Log("Constructing OmniMap (GL Version)");

  fragmentShaderFilename[0] = '\0';
  vertexShaderFilename[0] = '\0';


  glViewportsettings0 = OMNIMAP_DEFAULT_glViewportsettings0;
  glViewportsettings1 = OMNIMAP_DEFAULT_glViewportsettings1;
  glViewportsettings2 = OMNIMAP_DEFAULT_glViewportsettings2;
  glViewportsettings3 = OMNIMAP_DEFAULT_glViewportsettings3;
  GL_STATE_CLEAR_AT_STARTFRAME = OMNIMAP_DEFAULT_GL_STATE_CLEAR_AT_STARTFRAME;
  GL_STATE_glDisable_GL_DEPTH_TEST =OMNIMAP_DEFAULT_GL_STATE_glDisable_GL_DEPTH_TEST;
  GL_STATE_glDepthMask_FALSE = OMNIMAP_DEFAULT_GL_STATE_glDepthMask_FALSE;
  useMirror = false;

#ifdef USE_DOMEVIEW
  domeViewIPC = NULL;
  instance = NULL;
#endif
  omniSpout = NULL;

  logoTextureID = 0;

  SetUpPropertyAccess();
  glGetError();

  EH_GL_ASSERT("error after SetUpPropertyAccess");

  strcpy(rendererType, "OGL");
  ScreenRendererFactory.addScreenRendererCreator("OGL", &ScreenRendererOGL::CreateScreenRendererOGL);
  
  if (doInit)
    init();

  EH_OnError() {}
}




OmniMap::~OmniMap()
{
  Clear_Channels();
#ifdef USE_DOMEVIEW
  if (domeViewIPC) { domeViewIPC->release(); domeViewIPC = NULL; }
  if (instance) { FreeLibrary(instance); instance = NULL; }
#endif

  if (logoTextureID) { glDeleteTextures(1, (GLuint *) &logoTextureID); logoTextureID = NULL; }

  if (omniSpout) { delete omniSpout; omniSpout = NULL; }
  if (shaders) { delete ((OmniMap_Shader *) shaders); shaders = NULL; }
  ClearScreenShapes();
}






void OmniMap::SetUpPropertyAccess()
{
	///////////////
	access.Register("glViewportsettings0",&glViewportsettings0);
	access.Register("glViewportsettings1",&glViewportsettings1);
	access.Register("glViewportsettings2",&glViewportsettings2);
	access.Register("glViewportsettings3",&glViewportsettings3); 
	access.Register("GL_STATE_CLEAR_AT_STARTFRAME",&GL_STATE_CLEAR_AT_STARTFRAME); 
	access.Register("GL_STATE_glDisable_GL_DEPTH_TEST",&GL_STATE_glDisable_GL_DEPTH_TEST); 
	access.Register("GL_STATE_glDepthMask_FALSE",&GL_STATE_glDepthMask_FALSE); 
	access.Register("VertexShaderFile", &vertexShaderFilename[0]);
	access.Register("FragmentShaderFile", &fragmentShaderFilename[0]);
	access.Register("UseMirror", &useMirror);
	access.Register("MirrorRadius", &mirrorRadius);
	access.Register("MirrorGrace", &mirrorGrace);
	access.Register("MirrorCenter_x", &mirrorCenter.x);
	access.Register("MirrorCenter_y", &mirrorCenter.y);
	access.Register("MirrorCenter_z", &mirrorCenter.z);
	access.Register("MirrorProjectorPosition_x", &mirrorProjectorPosition.x);
	access.Register("MirrorProjectorPosition_y", &mirrorProjectorPosition.y);
	access.Register("MirrorProjectorPosition_z", &mirrorProjectorPosition.z);
	access.Register("MirrorProjectorUp_x", &mirrorProjectorUp.x);
	access.Register("MirrorProjectorUp_y", &mirrorProjectorUp.y);
	access.Register("MirrorProjectorUp_z", &mirrorProjectorUp.z);

	
#ifdef USE_DOMEVIEW
	access.Register("ApplicationCode", &ApplicationCode);
#endif
	OmniMapBase::SetUpPropertyAccess();

}





// OMNIMAP INIT
void OmniMap::init()
{
  char prelude[1024];
  std::string preludeStr;
  EH_DECLARE;

  std::string setLuaDir = "LuaSupportDir = \"";
  setLuaDir.append(luaSupportDir);
  setLuaDir.append("\"");
  size_t index = 0;
  while ((index = setLuaDir.find("\\", index)) != std::string::npos)
  {
    setLuaDir.replace(index, 1, "/");
    index++;
  }

  EH_Zero(ScriptingEngine->RunString(setLuaDir.c_str()));
  EH_Zero(ScriptingEngine->RunScript(StartUpScript));

#ifdef USE_DOMEVIEW
	ApplicationCode = 0;
#endif

  EH_GL_ASSERT("Error: ScriptingEngine->RunScript(StartUpScript);");

  EH_Ptr(shaders = new OmniMap_Shader());
  ((OmniMap_Shader *)shaders)->CobraWarpWithTrueDimension = (this)->CobraWarpWithTrueDimension;

  EH_GL_ASSERT("Error: shaders = new OmniMap_Shader();");
	
	if(CobraWarpWithTrueDimension>0){
		EH_Log("CobraWarpWithTrueDimension (0 is off 1 is Warp with TrueDimension On, 2 is Warp with TrueDimension off ) = %d",CobraWarpWithTrueDimension);
	}

	if(StencilMask_filename)
		((OmniMap_Shader *)shaders)->StencilMask_Load(StencilMask_filename); // the final mask needs to be done before the shader is compiled....


	if (vertexShaderFilename[0] != '\0' && fragmentShaderFilename[0] != '\0')
	{
		std::string vertShader = luaSupportDir + std::string(vertexShaderFilename);
		std::string fragShader = luaSupportDir + std::string(fragmentShaderFilename);
    EH_Log("loading shader %s",vertShader.c_str());
    EH_Log("loading shader %s",fragShader.c_str());
		shaders->setShadersFilenames(vertShader.c_str(), fragShader.c_str());
	}

  if (useMirror) {
		sprintf(prelude, fragShaderPrelude, 
			GetNumChannels(), 
			mirrorRadius,
			mirrorGrace,
			mirrorCenter.x, mirrorCenter.y, mirrorCenter.z,
			AudiencePosition.x, AudiencePosition.y, AudiencePosition.z,
			mirrorProjectorPosition.x, mirrorProjectorPosition.y, mirrorProjectorPosition.z,
			this->mirrorProjectorUp.x, mirrorProjectorUp.y, mirrorProjectorUp.z,
			StencilMask_filename?"#define STENCILMASK_ENABLE":"");
	} else {
		sprintf(prelude, "// Start Header: automatically generated by Omnimap\n#define MaxChannels %d\n%s\n// End Header\n\n", GetNumChannels(),StencilMask_filename?"#define STENCILMASK_ENABLE":"");
	}
	
  preludeStr = prelude;
	shaders->setShadersPrelude(preludeStr.c_str(), preludeStr.c_str());
	((OmniMap_Shader *) shaders)->setUseMirror(useMirror);
	shaders->init();

	this->LoadBGTexture();

#ifdef USE_DOMEVIEW
  EH_Zero(FileExist ("IPCDomeView.dll"),
    "---------------------------------------------------------------------\n"
    "-- NOT USING EXPERIMENTAL DOMEVIEW. ADD IPCDomeView.dll to enable it.\n"
    "---------------------------------------------------------------------\n"
    );

  EH_Ptr(instance = LoadLibrary(TEXT("IPCDomeView.dll")), "-- Could not load IPCDomeView.dll");
  EH_Ptr(IPCDomeViewBuilderFUNC IPCDomeViewBuilder = (IPCDomeViewBuilderFUNC) GetProcAddress(instance, "IPCDomeViewBuilder"));
  EH_Ptr(domeViewIPC = IPCDomeViewBuilder(IPC_DomeViewPlugin_Dummy), "Loading not successful");
  // SEE MORE DEFINES ON IPCPlugin.h
  EH_Log("-- WARNING USING EXPERIMENTAL DOMEVIEW. Remove IPCDomeView.dll to disable it.");
#endif

  if (useSpoutInFinalPassCamera){
    EH_Log("loading OmniSpout...");
    EH_Ptr(omniSpout = new OmniSpout("OmniMap"));
  }


	EH_Log("------------OMNIMAP LOADED DOWN----------------");

  EH_OnError() {
    EH_Log("------------OMNIMAP FAILDED TO LOAD----------------");

#ifdef USE_DOMEVIEW
    if (domeViewIPC) { domeViewIPC->release(); domeViewIPC = NULL; }
    if (instance) { FreeLibrary(instance); instance = NULL; }
#endif

    if (omniSpout) { delete omniSpout; omniSpout = NULL; }
    if (shaders) { delete ((OmniMap_Shader *) shaders); shaders = NULL; }
  }
  
  EH_Log("Use Mirror : %d", useMirror);
	EH_Log("glViewportsettings %f %f %f %f",glViewportsettings0,glViewportsettings1,glViewportsettings2,glViewportsettings3);
	EH_Log("GL_STATE_CLEAR_AT_STARTFRAME, GL_STATE_glDisable_GL_DEPTH_TEST,GL_STATE_glDepthMask_FALSE %d %d %d",	GL_STATE_CLEAR_AT_STARTFRAME, GL_STATE_glDisable_GL_DEPTH_TEST,GL_STATE_glDepthMask_FALSE );
	EH_Log("width %d",		resWidth);
	EH_Log("height %d",		resHeight);
	//EH_Log("fontname %s",strFont);
	//EH_Log("fontsize %f",font_size);
	EH_Log("displayHUD  %d",displayHUD );
	EH_Log("clear color %f %f %f %f",clearcolor_r,clearcolor_g,clearcolor_b,clearcolor_a );
	EH_Log("AudiencePosition %f %f %f\n",AudiencePosition.x,AudiencePosition.y,AudiencePosition.z);
	EH_Log("ProjectorPosition.pos %f %f %f\n",ProjectorPosition.pos.x,ProjectorPosition.pos.y,ProjectorPosition.pos.z);
	EH_Log("ProjectorPosition.headsUp %f %f %f\n",ProjectorPosition.headsUp.x,ProjectorPosition.headsUp.y,ProjectorPosition.headsUp.z);
	EH_Log("ProjectorPosition.lookAtpos %f %f %f\n",ProjectorPosition.lookAtpos.x,ProjectorPosition.lookAtpos.y,ProjectorPosition.lookAtpos.z);
	EH_Log("startupscript : %s",StartUpScript);
	EH_Log("------------------------------");
}







void OmniMap::SetupScriptingCommands()
{
}







OmniMapChannelBase *OmniMap::Create_Channel(const char * name) 
{
  name;
	return new OmniMap_Channel();
}



/*
OmniMap_Screen *OmniMap::Create_ScreenShape(const char * name)
{
	OmniMap_Screen_Dome *p = new OmniMap_Screen_Dome();
	return(p);
}


#ifdef OmniMap_QUAD_UPGRADE
void OmniMap::Create_ScreenShapeQuad(std::string name)
{
	// prevent name conflict
	String_OmniMap_Screen_Map_itor itr = OmniMap_GLOBAL_ScreenShapes.find(name);
	if(itr !=OmniMap_GLOBAL_ScreenShapes.end())
	{
		LogSystem()->ReportError("Error:\t ScreenShape Name Conflict %s!\n",name.c_str());
		delete itr->second;
	}

	OmniMap_GLOBAL_ScreenShapes[name]= new OmniMap_Screen_Quad(); 
}
#endif
*/




void OmniMap::SetupAllShaderVaribles()
{
	int N_Channels = 0;
	int TextureIds[OMNIMAP_maxChannelFaces];
/*
	if (((OmniMap_Shader *) shaders)->_glsl_debug1)
		((OmniMap_Shader *) shaders)->_glsl_debug1->set((GLint) 1);
*/
	GetShaderVariables(N_Channels, (int *) &(TextureIds[0]));
	((OmniMap_Shader *) shaders)->SetTextureIds(N_Channels,TextureIds);


	int texturenonarbnumber = N_Channels+1;
	if(StencilMask_filename)
		((OmniMap_Shader *) shaders)->StencilMask_Bind(texturenonarbnumber);//+1
}




void OmniMap::DrawHeadsUpDisplay()
{
	glDisable(GL_DEPTH_TEST);
	DrawHeadsUpDisplays();
	glEnable(GL_DEPTH_TEST);
}





void OmniMap::LoadAndPush_HUD_Matricies()
{
  EH_DECLARE;
  glViewport(	0,
    0,
    resWidth,/// aspectratio
    resHeight );
  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();
  glOrtho(-1,1,-1,1,-1,1);
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();	
  EH_GL_ASSERT("checkGLError()");
  EH_OnError() {}
}




void OmniMap::doGluLookAt()
{
  gluLookAt (
    ProjectorPosition.pos.x,
    ProjectorPosition.pos.y,
    ProjectorPosition.pos.z,
    ProjectorPosition.lookAtpos.x,
    ProjectorPosition.lookAtpos.y,
    ProjectorPosition.lookAtpos.z,
    ProjectorPosition.headsUp.x,
    ProjectorPosition.headsUp.y,
    ProjectorPosition.headsUp.z);
}





void OmniMap::LoadBGTexture()
{
}




void OmniMap::RenderBG(float x, float y, float w, float h, float r, float s)
{
  x;y;w;h;r;s;
}





void OmniMap::LoadAndPush_ProjectiveTexturing_Matricies()
{
  EH_DECLARE;

  EH_GL_ASSERT("checkGLError()");
  // Load Matricies
  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();

  if (glViewportsettings2 <1.0f)
    glViewportsettings2= (float)this->resWidth;
  if(glViewportsettings3<1.0f)
    glViewportsettings3 =(float) this->resHeight;


  //	EH_Log("glv %f %f %f %f",glViewportsettings0,glViewportsettings1,glViewportsettings2,glViewportsettings3);

  glViewport((GLint)glViewportsettings0,
    (GLint)glViewportsettings1,
    (GLsizei)glViewportsettings2,
    (GLsizei)glViewportsettings3);


  glOrtho(-1.0f,1.0f,-1.0f,1.0f,-1.0f,1.0f);
  EH_GL_ASSERT("checkGLError()");

  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
  doGluLookAt();


  //for (int i = 0; i < this->GetNumChannels(); i++)
  for (int i = this->GetNumChannels()-1; i >= 0; i--)
  {

    OmniMapChannelBase *channel = this->GetChannel(i);
    glActiveTextureARB(OmniMap_getGL_TEXTUREN_ARB_From_N(i)); 
    channel->BindTexture(i);
    glMatrixMode(GL_TEXTURE);
    glPushMatrix();
    glLoadIdentity();
    glTranslatef(.5f, .5f, .5f);

    glScalef(.5f, .5f, .5f);

    channel->ApplyProjectionMatrix();

    channel->ApplyViewMatrix();

    glMatrixMode(GL_MODELVIEW);
    EH_GL_ASSERT("checkGLError()");
  }
  EH_OnError() {}
}




void OmniMap::PopMatricies()
{
  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();
}




void OmniMap::Clear()
{
  glClearColor(clearcolor_r,clearcolor_g,clearcolor_b,clearcolor_a); 
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	 
}




void OmniMap::PostRender()
{
  EH_DECLARE;
  glPushAttrib(GL_ALL_ATTRIB_BITS);

  glDisable(GL_ALPHA_TEST);
  glDisable(GL_BLEND);
  glDisable(GL_CULL_FACE);
  glDisable(GL_LIGHTING);
  glDisable(GL_DEPTH_TEST);
	


	//glEnable(GL_TEXTURE_RECTANGLE_ARB);
	glEnable(GL_TEXTURE_2D);
	//glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR); 
	//glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR); 

	// Post Render does a few things
	// A0 Clear
	// B1 set the projective shader
	// B2 Set up Shaders 
	// B3 textures
	// B4 Set up matricies
	// C1 Display Screen
	// D0 disable shaders
	// D1 Disable Textures
	// D2 Set active texutre to 0

	// E0 PushAndSetupMatrix
	// E1 draw lua console
	// E2 draw heads up display
	// E7 PopMatrix
	//  8 

	// A. 0 Clear
	if(GL_STATE_CLEAR_AT_STARTFRAME)
		Clear();

	// B.1 set the projective shader
	shaders->EnableShader();

	// B.2  set the textures
	BindAllChannelTextures();

	// B.3 Shader Parameters
	SetupAllShaderVaribles();

	// B.4 Set up matricies
	LoadAndPush_ProjectiveTexturing_Matricies();

	if(GL_STATE_glDisable_GL_DEPTH_TEST)
		glDisable(GL_DEPTH_TEST);
	if(GL_STATE_glDepthMask_FALSE)
		glDepthMask(false);
	// C.1 Display World

	DisplayScreenShapes();
	for (int i = 0; i < this->GetNumChannels(); i++)
	{
		OmniMapChannelBase *channel = this->GetChannel(i);
		glActiveTextureARB(OmniMap_getGL_TEXTUREN_ARB_From_N(i));
		channel->BindTexture(i);
		glMatrixMode(GL_TEXTURE);
		glPopMatrix();
	}

	PopMatricies();

	// D0 disable shaders
	shaders->DisableShader(); // use fixed pipeline

	// D1 Disable Textures
	UnBindAllChannelTextures();


	// D2 Set ARB0
	// this might be wrong
	glActiveTextureARB(OmniMap_getGL_TEXTUREN_ARB_From_N(0));

	// E0 PushAndSetupMatrix
	LoadAndPush_HUD_Matricies();

	// E1 draw lua console
		//		if(console->display_Console)
		//		  console->DisplayConsole();
	// E2 Draw HUD

	if(displayHUD)
		DrawHeadsUpDisplay();

	if(GL_STATE_glDisable_GL_DEPTH_TEST)
		glEnable(GL_DEPTH_TEST);
	if(GL_STATE_glDepthMask_FALSE)
		glDepthMask(true);
	// E7 PopMatrix
	PopMatricies();
		
	
  EH_GL_ASSERT("checkGLError()");

	glPopAttrib();


#ifdef USE_DOMEVIEW
 /*
	if (domeViewIPC == NULL && ApplicationCode != 0)
	{
		domeViewIPC = new IPCDomeView(IPC_DomeViewPlugin_OmniMapFlag | ApplicationCode);	
	}
		*/ 
	if (domeViewIPC)
	{
		if (domeViewIPC->isFree(this->resWidth, this->resHeight, Format_RGB)) {
			//domeViewIPC->pluginIPC->setParamsFilled(PARAMS_EMPTY);
			//domeViewIPC->pluginIPC->setProjection(PROJECTION_AzimuthalEquidistant);
			//domeViewIPC->pluginIPC->setMirror(MIRROR_X);
			//domeViewIPC->pluginIPC->setAlt(90.0);
			//domeViewIPC->pluginIPC->setAzi(0.0);
			//domeViewIPC->pluginIPC->setRotation(0);
			//domeViewIPC->pluginIPC->setAngularWidth(180.0);
			//domeViewIPC->pluginIPC->setAngularHeight(135.0);
			void *pixel = domeViewIPC->getBuffer();
			glReadPixels(0, 0, this->resWidth, this->resHeight, GL_RGB, GL_UNSIGNED_BYTE, pixel);
			domeViewIPC->done();
		}
	}


#endif
	/// SPOUT
	if(omniSpout!=NULL) {
		omniSpout->UpdateSpoutGL(resWidth,resHeight);
	}
	for (int i = 0; i < this->GetNumChannels(); i++) {
		OmniMap_Channel *channel = (OmniMap_Channel*)this->GetChannel(i);
		if(channel !=0 && channel->prc_RenderChannel!=0) {
			channel->prc_RenderChannel->UpdateSpout(channel);
		}
	}
  EH_OnError() {}
}




