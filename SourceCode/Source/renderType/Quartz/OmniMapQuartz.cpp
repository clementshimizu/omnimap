/*
 *  OmniMapQuartz.cpp
 *  QuartzGLTest
 *
 *  Created by Jim Terhorst on 1/29/08.
 *  Copyright 2008 __MyCompanyName__. All rights reserved.
 *
 */

#include "OmniMapQuartz.h"
#ifdef notdef
#include <OmniMapAPI/OM_FlatScreen.h>
#endif
#include <OpenGL/glu.h>
#include <assert.h>
#include <string>
#include "simple_matrix.h"


static int OmniMap_getGL_TEXTUREN_ARB_From_N(int n)
{
	switch(n)
	{
		case 0: return GL_TEXTURE0_ARB;break;
		case 1: return GL_TEXTURE1_ARB;break;
		case 2: return GL_TEXTURE2_ARB;break;
		case 3: return GL_TEXTURE3_ARB;break;
		case 4: return GL_TEXTURE4_ARB;break;
		case 5: return GL_TEXTURE5_ARB;break;
		case 6: return GL_TEXTURE6_ARB;break;
		case 7: return GL_TEXTURE7_ARB;break;
		case 8: return GL_TEXTURE8_ARB;break;
		case 9: return GL_TEXTURE9_ARB;break;
	}
	assert(0 && "Error! getNumberFromGL_TEXTUREID_ARB");
	return GL_TEXTURE0_ARB;
}


static bool checkGLError() {
	int ret = glGetError();
	if (ret!=0L) {
		if (ret == GL_INVALID_ENUM) {
			LogSystem()->ReportError("GL_INVALID_ENUM ");
		}
		else if (ret == GL_INVALID_VALUE) {
			LogSystem()->ReportError("GL_INVALID_VALUE ");
		}
		else if (ret == GL_INVALID_OPERATION) {
			LogSystem()->ReportError("GL_INVALID_OPERATION ");
		}
		else if (ret == GL_STACK_OVERFLOW) {
			LogSystem()->ReportError("GL_STACK_OVERFLOW ");
		}
		else if (ret == GL_STACK_UNDERFLOW) {
			LogSystem()->ReportError("GL_STACK_UNDERFLOW ");
		}
		else if (ret == GL_OUT_OF_MEMORY) {
			LogSystem()->ReportError("GL_OUT_OF_MEMORY ");
		}
		else LogSystem()->ReportError("GL OTHER PROBLEM???");

		return false;
	}
	return true;
}


OmniMapQuartz::OmniMapQuartz(int _resW, int _resH,
		const char* strStartUpScriptFile,
		const char *luaResDir) :
	OmniMap(_resW, _resH, strStartUpScriptFile, luaResDir, false)
{
	SetUpPropertyAccess();
#ifdef notdef
	useFlatScreen = false;
	flatScreen = new OM_FlatScreen();
#endif
	
}


OmniMapChannelBase *OmniMapQuartz::Create_Channel(const char * name) 
{
	
	OmniMapChannelQuartz *channel = new OmniMapChannelQuartz();
	return(channel);
}

void OmniMapQuartz::SetUpPropertyAccess()
{
	///////////////
#ifdef notdef
	access.Register("UseFlatScreen",&useFlatScreen);
#endif
}

void OmniMapQuartz::init()
{

	std::string setLuaDir = "LuaSupportDir = \"";
	setLuaDir.append(luaSupportDir);
	setLuaDir.append("\"");
	doWireframe = false;
	size_t index = 0;
	while ((index = setLuaDir.find("\\", index)) != std::string::npos)
	{
		setLuaDir.replace(index, 1, "/");
		index++;
	}

	ScriptingEngine->RunString(setLuaDir.c_str());
	ScriptingEngine->RunScript(StartUpScript);
#ifdef notdef
	flatScreen->access.SetValue("Screen_ApexDirection.x", 
		this->GetScreenShape(0)->access.GetNumber("Dome_ApexDirection.x"));
	flatScreen->access.SetValue("Screen_ApexDirection.y", 
		this->GetScreenShape(0)->access.GetNumber("Dome_ApexDirection.y"));
	flatScreen->access.SetValue("Screen_ApexDirection.z", 
		this->GetScreenShape(0)->access.GetNumber("Dome_ApexDirection.z"));
	//flatScreen->access.SetValue("Screen_tesselation", 5);

	flatScreen->CreateGeometry();
	ScreenRendererBase *flatScreenRenderer = ScreenRendererFactory.Create_ScreenRenderer("OGL");
	flatScreen->SetRenderer(flatScreenRenderer);
#endif
	
	

#ifdef NOTNOW
	assert(checkGLError() && "Error: ScriptingEngine->RunScript(StartUpScript);");

	shaders = new OmniMap_Shader();

	assert(checkGLError() && "Error: shaders = new OmniMap_Shader();");

	
	//if(StencilMask_filename)
		//((OmniMap_Shader *)shaders)->StencilMask_Load(StencilMask_filename); // the final mask needs to be done before the shader is compiled....

	if (vertexShaderFilename[0] != '\0' && fragmentShaderFilename[0] != '\0')
	{
		std::string vertShader = luaSupportDir;
		std::string fragShader = luaSupportDir;
		vertShader.append(vertexShaderFilename);
		fragShader.append(fragmentShaderFilename);
		shaders->setShadersFilenames(vertShader.c_str(), fragShader.c_str());
	}

	char prelude[512];
	sprintf(prelude, "// Start Header: automatically generated by Omnimap\n#define MaxChannels %d\n%s\n// End Header\n\n", GetNumChannels(),StencilMask_filename?"#define STENCILMASK_ENABLE":"");
	std::string preludeStr = prelude;
	//shaders->setShadersPrelude(preludeStr.c_str(), preludeStr.c_str());
	shaders->init();

	this->LoadBGTexture();
	
#endif
	LogSystem()->ReportMessage("------------OMNIMAP LOADED DOWN----------------");
	LogSystem()->ReportMessage("glViewportsettings %f %f %f %f",glViewportsettings0,glViewportsettings1,glViewportsettings2,glViewportsettings3);
	LogSystem()->ReportMessage("GL_STATE_CLEAR_AT_STARTFRAME, GL_STATE_glDisable_GL_DEPTH_TEST,GL_STATE_glDepthMask_FALSE %d %d %d",	GL_STATE_CLEAR_AT_STARTFRAME, 
		GL_STATE_glDisable_GL_DEPTH_TEST,GL_STATE_glDepthMask_FALSE );
	LogSystem()->ReportMessage("width %d",		resWidth);
	LogSystem()->ReportMessage("height %d",		resHeight);
	//LogSystem()->ReportMessage("fontname %s",strFont);
	//LogSystem()->ReportMessage("fontsize %f",font_size);
	LogSystem()->ReportMessage("displayHUD  %d",displayHUD );
	LogSystem()->ReportMessage("clear color %f %f %f %f",clearcolor_r,clearcolor_g,clearcolor_b,clearcolor_a );
	LogSystem()->ReportMessage("AudiencePosition %f %f %f\n",AudiencePosition.x,AudiencePosition.y,AudiencePosition.z);
	LogSystem()->ReportMessage("ProjectorPosition.pos %f %f %f\n",ProjectorPosition.pos.x,ProjectorPosition.pos.y,ProjectorPosition.pos.z);
	LogSystem()->ReportMessage("ProjectorPosition.headsUp %f %f %f\n",ProjectorPosition.headsUp.x,ProjectorPosition.headsUp.y,ProjectorPosition.headsUp.z);
	LogSystem()->ReportMessage("ProjectorPosition.lookAtpos %f %f %f\n",ProjectorPosition.lookAtpos.x,ProjectorPosition.lookAtpos.y,ProjectorPosition.lookAtpos.z);
	LogSystem()->ReportMessage("startupscript : %s",StartUpScript);
	LogSystem()->ReportMessage("------------------------------");

}

void OmniMapQuartz::setLensOffsetParams(float x, float y, float z)
{
	if (x != cropOffsetX || y != cropOffsetY || z != cropOffsetZ)
	{
		cropOffsetX = x;
		cropOffsetY = y;
		cropOffsetX = z;
		char setCropScript[1024];
		sprintf(setCropScript, "SetglViewportsettings(%f, %f, %f)\n", 
							  cropOffsetX, cropOffsetY, cropOffsetZ);
		this->ScriptingEngine->RunString(setCropScript);
	}
}

void OmniMapQuartz::setFlatScreenOrientation(double x, double y, double z)
{
#ifdef notdef
	float domeOrientX = flatScreen->access.GetNumber("Screen_ApexDirection.x");
	float domeOrientY = flatScreen->access.GetNumber("Screen_ApexDirection.y");
	float domeOrientZ = flatScreen->access.GetNumber("Screen_ApexDirection.z");
#endif
	OmniMap_Screen *domeScreen = this->GetScreenShape(0);
	float domeOrientX = domeScreen->access.GetNumber("Dome_ApexDirection.x");
	float domeOrientY = domeScreen->access.GetNumber("Dome_ApexDirection.y");
	float domeOrientZ = domeScreen->access.GetNumber("Dome_ApexDirection.z");
	
	if (x != domeOrientX || y != domeOrientY || z != domeOrientZ)
	{
#ifdef notdef
		flatScreen->access.SetValue("Screen_ApexDirection.x", (float) x);
		flatScreen->access.SetValue("Screen_ApexDirection.y", (float) y);
		flatScreen->access.SetValue("Screen_ApexDirection.z", (float) z);
				flatScreen->access.SetValue("needsrecompile", true);
#endif
		domeScreen->access.SetValue("Dome_ApexDirection.x", (float) x);
		domeScreen->access.SetValue("Dome_ApexDirection.y", (float) y);
		domeScreen->access.SetValue("Dome_ApexDirection.z", (float) z);
		domeScreen->access.SetValue("needsrecompile", true);
	}
	
}

void OmniMapQuartz::rollProjector(double angle)
{
	OmniVec3 up(ProjectorPosition.headsUp);
	OmniVec3 rollAxis(ProjectorPosition.lookAtpos);
	rollAxis.add(
		OmniVec3(-ProjectorPosition.pos.x, -ProjectorPosition.pos.y, -ProjectorPosition.pos.z));
	rollAxis.normalize();
	ProjectorPosition.headsUp = up.rotateByVector(rollAxis, angle);
}

void OmniMapQuartz::rotateProjector(double axisX, double axisY, double axisZ, double rads)
{
	OmniVec3 look(0.0,0.0,-1.0);
	OmniVec3 up(0.0,1.0,0.0);
	
	OmniVec3 newLook = look.rotateByVector(OmniVec3(axisX, axisY, axisZ), rads);
	
	ProjectorPosition.lookAtpos = ProjectorPosition.pos;
	ProjectorPosition.lookAtpos.add(newLook);
	ProjectorPosition.headsUp = up.rotateByVector(OmniVec3(axisX, axisY, axisZ), rads);
	
}

void OmniMapQuartz::setProjectorValues(double posX, double posY, double posZ, 
		double lookVecX, double lookVecY, double lookVecZ,
		double upX, double upY, double upZ)
{
	ProjectorPosition.lookAtpos.add(
		OmniVec3(-ProjectorPosition.pos.x, -ProjectorPosition.pos.y, -ProjectorPosition.pos.z));
	ProjectorPosition.pos = OmniVec3(posX, posY, posZ);	
	ProjectorPosition.lookAtpos.add(ProjectorPosition.pos);
	/*
	ProjectorPosition.lookAtpos = ProjectorPosition.pos;
	ProjectorPosition.lookAtpos.add(OmniVec3(lookVecX, lookVecY, lookVecZ));
	ProjectorPosition.headsUp.set(upX, upY, upZ);
	*/
	
}

void OmniMapQuartz::setupProjTextMats(int startChan, int endChan)
{
 	assert(checkGLError() &&"checkGLError() ");
	// Load Matricies
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	

	if (glViewportsettings2 <1.0f)
		glViewportsettings2= (float)this->resWidth;
	if(glViewportsettings3<1.0f)
		glViewportsettings3 =(float) this->resHeight;
		
	glViewport((int) glViewportsettings0, (int) glViewportsettings1,
		(int) glViewportsettings2, (int) glViewportsettings3);
	/*	glViewport((int)	glViewportsettings0,
			(int)glViewportsettings1,
			(int)glViewportsettings2,
			(int)glViewportsettings3);*/
	//gluPerspective(2.0, 1.33333, .01, 100.0);
 	glOrtho(-1.0f,1.0f,-1.0f,1.0f,-1.0f,1.0f);
	assert(checkGLError() &&"checkGLError() ");

	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();
	doGluLookAt();

	int numTextures = 0;
	for (int i = startChan; i <= endChan; i++)
	//for (int i = this->GetNumChannels()-1; i >= 0; i--)
	{
		
		OmniMapChannelBase *channel = this->GetChannel(i);
		const char *chanName = this->GetChannelName(channel);
		float x, y, z;
		channel->GetEulerAngles(&x, &y, &z);
		int numUnits;
		
		glGetIntegerv(GL_MAX_VARYING_FLOATS, &numUnits);

		GLint textureUnit = OmniMap_getGL_TEXTUREN_ARB_From_N(i);
			glActiveTextureARB(textureUnit);
			
			assert(checkGLError() &&"checkGLError() ");
		
			glGetIntegerv(GL_TEXTURE_BINDING_2D, &(textUnitTID[i]));
			if (textUnitTID[i] == 0)
				continue;
		float m[16];
		numTextures++;
		glMatrixMode(GL_TEXTURE);
		glPushMatrix();
		glLoadIdentity();
		glTranslatef(.5f, .5f, .5f);
		glScalef(.5f, .5f, .5f);
		
		channel->ApplyProjectionMatrix();
		if (glGetError() != 0)
			continue;
	
		channel->ApplyViewMatrix();
		if (glGetError() != 0)
			continue;
		glMatrixMode(GL_MODELVIEW);
		
	}
	glMatrixMode(GL_MODELVIEW);



}

void OmniMapQuartz::LoadAndPush_ProjectiveTexturing_Matricies()
{

 	assert(checkGLError() &&"checkGLError() ");
	// Load Matricies
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	if (doWireframe)
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

	if (glViewportsettings2 <1.0f)
		glViewportsettings2= (float)this->resWidth;
	if(glViewportsettings3<1.0f)
		glViewportsettings3 =(float) this->resHeight;
		
	glViewport((int) glViewportsettings0, (int) glViewportsettings1,
		(int) glViewportsettings2, (int) glViewportsettings3);
	/*	glViewport((int)	glViewportsettings0,
			(int)glViewportsettings1,
			(int)glViewportsettings2,
			(int)glViewportsettings3);*/
	//gluPerspective(2.0, 1.33333, .01, 100.0);
 	glOrtho(-1.0f,1.0f,-1.0f,1.0f,-1.0f,1.0f);
	assert(checkGLError() &&"checkGLError() ");

	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();
	doGluLookAt();

	int numTextures = 0;
	for (int i = 0; i < this->GetNumChannels(); i++)
	//for (int i = this->GetNumChannels()-1; i >= 0; i--)
	{
		
		OmniMapChannelBase *channel = this->GetChannel(i);
		const char *chanName = this->GetChannelName(channel);
		float x, y, z;
		channel->GetEulerAngles(&x, &y, &z);
		int numUnits;
		glGetIntegerv(GL_MAX_VARYING_FLOATS, &numUnits);
		GLint textureUnit = OmniMap_getGL_TEXTUREN_ARB_From_N(i);
			glActiveTextureARB(textureUnit);
			
			assert(checkGLError() &&"checkGLError() ");
		
			glGetIntegerv(GL_TEXTURE_BINDING_2D, &(textUnitTID[i]));
			if (textUnitTID[i] == 0)
				continue;
			glBindTexture(GL_TEXTURE_2D, textUnitTID[i]);
			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);//GL_CLAMP
			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);//GL_CLAMP
		float m[16];
		numTextures++;
		glMatrixMode(GL_TEXTURE);
		glPushMatrix();
		glLoadIdentity();
		glTranslatef(.5f, .5f, .5f);
		glScalef(.5f, .5f, .5f);
		
		channel->ApplyProjectionMatrix();
		if (glGetError() != 0)
			continue;
	
		channel->ApplyViewMatrix();
		if (glGetError() != 0)
			continue;
		glMatrixMode(GL_MODELVIEW);
		
	}
	glMatrixMode(GL_MODELVIEW);

}






void OmniMapQuartz::PostRender()
{
	glPushAttrib(GL_ALL_ATTRIB_BITS);
	//glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);

    //glDisable(GL_ALPHA_TEST);
	
    //glDisable(GL_BLEND);
	glEnable(GL_ALPHA_TEST);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glDisable(GL_CULL_FACE);
	//glCullFace(GL_BACK);
	glDisable(GL_LIGHTING);
	glDisable(GL_DEPTH_TEST);
	//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	


	// B.4 Set up matricies
	LoadAndPush_ProjectiveTexturing_Matricies();
	//setupProjTextMats(0,6);

	//if(GL_STATE_glDisable_GL_DEPTH_TEST)
		glDisable(GL_DEPTH_TEST);
	//if(GL_STATE_glDepthMask_FALSE)
		glDepthMask(false);
	// C.1 Display World

		DisplayScreenShapes();
		
		
	//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	//DisplayScreenShapes();

	for (int i = 0; i < this->GetNumChannels(); i++)
	{
		if (textUnitTID[i] != 0)
		{
			OmniMapChannelBase *channel = this->GetChannel(i);
			glActiveTextureARB(OmniMap_getGL_TEXTUREN_ARB_From_N(i));
			channel->BindTexture(i);
			glMatrixMode(GL_TEXTURE);
			glPopMatrix();
		}
	}


	PopMatricies();
	glPopAttrib();
}


OmniMapChannelQuartz::OmniMapChannelQuartz() :
	OmniMap_Channel()
{
	textureID = -1;
}

#ifdef notdef
void OmniMapChannelQuartz::BindTexture(int index)
{
	oglTextureUnit = index;
}
#endif

void OmniMapChannelQuartz::BindTexture(int index)
{
		glActiveTextureARB(OmniMap_getGL_TEXTUREN_ARB_From_N(index));
		int glerr = glGetError();

		glEnable(GL_TEXTURE_RECTANGLE_ARB);
		glBindTexture(GL_TEXTURE_RECTANGLE_ARB, textureID);
		//glEnable(GL_TEXTURE_2D);
		//glBindTexture(GL_TEXTURE_2D, textureID);
		glerr = glGetError();
		int i = glerr+1;
	}

void OmniMapChannelQuartz::UnbindTexture(int index)
{
	glActiveTextureARB(OmniMap_getGL_TEXTUREN_ARB_From_N(index));
	glDisable(GL_TEXTURE_RECTANGLE_ARB);
	//textureID = -1;
}

void OmniMapChannelQuartz::SetTexureID(unsigned int id)
{
	textureID = id;
}

void OmniMapChannelQuartz::Initialize()
{
}

void OmniMapChannelQuartz::ApplyViewMatrix() // assume world space
{
	//glTranslatef(audPosX, audPosY, audPosZ);
	glMultMatrixf(cam_info.Matrix_WorldView);

}

void OmniMapChannelQuartz::beginRenderToChannel()
{
    if (useOmniMapMatrix)
        PushSetupMatricies();

}
void OmniMapChannelQuartz::endRenderToChannel()
{
    if (useOmniMapMatrix)
	    PopSetupMatricies();
}

void OmniMapChannelQuartz::DrawHeadsUpDisplay()
{
}

void OmniMapChannelQuartz::SetAudiencePos(float x, float y, float z)
{/*
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();
	
	glMultMatrixf(this->cam_info.Matrix_WorldView);
	glTranslatef(x, y, z);
	glGetFloatv(GL_MODELVIEW_MATRIX, this->cam_info.Matrix_WorldView);
	glPopMatrix();
 */
	//this->cam_info.Matrix_WorldView[3*4+0] = -x;
	//this->cam_info.Matrix_WorldView[3*4+1] = -y;
	//this->cam_info.Matrix_WorldView[3*4+2] = -z;
	 
	audPosX = x;
	audPosY = y;
	audPosZ = z;
	
}

void OmniMapChannelQuartz::TransformPoint(float mat[16], float pt[3], float transformedPt[3])
{
	HPoint ptToTrans(&(pt[0]));
	
	simMatrix_4x4 theTransform(&mat[0]);
	HPoint transedPt;
	
	theTransform.transformPoint(ptToTrans, transedPt);
	
	transformedPt[0] = transedPt.getVal(0);
	transformedPt[1] = transedPt.getVal(1);
	transformedPt[2] = transedPt.getVal(2);

}


