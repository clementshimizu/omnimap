static char effectOmniMapDome[] = { 
"#if HAS_OMNIMAP_MULTISAMPLE_9X\n" 
"#define HAS_OMNIMAP_MULTISAMPLE 1\n" 
"#endif\n" 
"#if HAS_OMNIMAP_MULTISAMPLE_9X\n" 
"#ifdef FILTER_SCALE\n" 
"float samplelength = (FILTER_SCALE);\n" 
"#else\n" 
"float samplelength = 1.0;\n" 
"#endif\n" 
"half4 MultiSampleHalf(sampler2D  tex , half2 UV){\n" 
"	half samplelengthScaled = samplelength *0.75;\n" 
"	half3 offset = half3(-.5,0,.5);\n" 
"	half2 offsetNormalized = half2(-0.70710678118*.5,0.70710678118*.5);\n" 
"	// to do switch to 4x rotated square pattern\n" 
"	\n" 
"	offset = offset*samplelength;\n" 
"	offsetNormalized = offsetNormalized*samplelengthScaled;	\n" 
"	\n" 
"	\n" 
"	half2 DUV = fwidth(UV);\n" 
"	half4 mainColor = (\n" 
"		tex2D(tex, UV + DUV *offsetNormalized.xy ) +\n" 
"		tex2D(tex, UV + DUV *offset.yz) +\n" 
"		tex2D(tex, UV + DUV *offsetNormalized.yy) +\n" 
"					\n" 
"		tex2D(tex, UV + DUV *offset.xy) +\n" 
"		tex2D(tex, UV)+\n" 
"		tex2D(tex, UV + DUV *offset.zy) +\n" 
"					\n" 
"		tex2D(tex, UV + DUV *offsetNormalized.xx)+\n" 
"		tex2D(tex, UV + DUV *offset.yx)+\n" 
"		tex2D(tex, UV + DUV *offsetNormalized.yx) \n" 
"	)*.111111111111111;\n" 
"	return mainColor;\n" 
"}\n" 
"float4 MultiSampleFloat(sampler2D  tex , float2 UV){\n" 
"	float samplelengthScaled = samplelength *0.75;\n" 
"	float3 offset = half3(-.5,0,.5);\n" 
"	float2 offsetNormalized = half2(-0.70710678118*.5,0.70710678118*.5);\n" 
"	// to do switch to 4x rotated square pattern\n" 
"	\n" 
"	offset = offset*samplelength;\n" 
"	offsetNormalized = offsetNormalized*samplelengthScaled;	\n" 
"	\n" 
"	float2 DUV = fwidth(UV);\n" 
"	float4 mainColor = (\n" 
"		tex2D(tex, UV + DUV *offsetNormalized.xy ) +\n" 
"		tex2D(tex, UV + DUV *offset.yz) +\n" 
"		tex2D(tex, UV + DUV *offsetNormalized.yy) +\n" 
"					\n" 
"		tex2D(tex, UV + DUV *offset.xy) +\n" 
"		tex2D(tex, UV)+\n" 
"		tex2D(tex, UV + DUV *offset.zy) +\n" 
"					\n" 
"		tex2D(tex, UV + DUV *offsetNormalized.xx)+\n" 
"		tex2D(tex, UV + DUV *offset.yx)+\n" 
"		tex2D(tex, UV + DUV *offsetNormalized.yx) \n" 
"	)*.111111111111111;\n" 
"	\n" 
"	return mainColor;\n" 
"}\n" 
"#endif\n" 
"#if HAS_OMNIMAP_MULTISAMPLE\n" 
"	#define MULTISAMPLE_Hin_Hout(t,uv) MultiSampleHalf((t),(uv))\n" 
"	#define MULTISAMPLE_Fin_Fout(t,uv) MultiSampleFloat((t),(uv))\n" 
"#else\n" 
"	#define MULTISAMPLE_Hin_Hout(t,uv) tex2D((t),(uv))\n" 
"	#define MULTISAMPLE_Fin_Fout(t,uv) tex2D((t),(uv))\n" 
"#endif\n" 
"//////////////////////////////////////////////\n" 
"////////////  MULTISAMPLE END ////////////////\n" 
"//////////////////////////////////////////////\n" 
"//--------------------------------------------------------------------------------------\n" 
"// Global variables\n" 
"//--------------------------------------------------------------------------------------\n" 
"float4x4 g_mProjection : VIEWPROJECTION;    // Projection matrix\n" 
"float4x4 g_mWorldView : WORLD;    // World * View\n" 
"float yOffset1;		// Lens offset Values\n" 
"float yOffset2;\n" 
"float yScale;		\n" 
"texture  channelTexture0;\n" 
"texture  channelTexture1;\n" 
"texture  channelTexture2;\n" 
"texture  channelTexture3;\n" 
"texture  channelTexture4;\n" 
"texture  channelTexture5;\n" 
"texture alphaMaskText;\n" 
"sampler2D alphMaskSampler =\n" 
"sampler_state\n" 
"{\n" 
"    Texture = <alphaMaskText>;\n" 
"    magfilter = LINEAR;\n" 
"	minfilter = LINEAR;\n" 
"	mipfilter = LINEAR;\n" 
"    AddressU = Clamp;\n" 
"    AddressV = Clamp;\n" 
"};\n" 
"sampler Samplers[6] = {\n" 
" sampler_state\n" 
" {\n" 
"  texture = <channelTexture0>;\n" 
"  magfilter = LINEAR;\n" 
"  minfilter = LINEAR;\n" 
"  mipfilter = LINEAR;\n" 
"  AddressU = Clamp;\n" 
"  AddressV = Clamp;\n" 
" },\n" 
" sampler_state\n" 
" {\n" 
"  texture = <channelTexture1>;\n" 
"  magfilter = LINEAR;\n" 
"  minfilter = LINEAR;\n" 
"  mipfilter = LINEAR;\n" 
"  AddressU = Clamp;\n" 
"  AddressV = Clamp;\n" 
" },\n" 
" sampler_state\n" 
" {\n" 
"  texture = <channelTexture2>;\n" 
"  magfilter = LINEAR;\n" 
"  minfilter = LINEAR;\n" 
"  mipfilter = LINEAR;\n" 
"  AddressU = Clamp;\n" 
"  AddressV = Clamp;\n" 
" },\n" 
" sampler_state\n" 
" {\n" 
"  texture = <channelTexture3>;\n" 
"  magfilter = LINEAR;\n" 
"  minfilter = LINEAR;\n" 
"  mipfilter = LINEAR;\n" 
"  AddressU = Clamp;\n" 
"  AddressV = Clamp;\n" 
" },\n" 
" sampler_state\n" 
" {\n" 
"  texture = <channelTexture4>;\n" 
"  magfilter = LINEAR;\n" 
"  minfilter = LINEAR;\n" 
"  mipfilter = LINEAR;\n" 
"  AddressU = Clamp;\n" 
"  AddressV = Clamp;\n" 
" },\n" 
" sampler_state\n" 
" {\n" 
"  texture = <channelTexture5>;\n" 
"  magfilter = LINEAR;\n" 
"  minfilter = LINEAR;\n" 
"  mipfilter = LINEAR;\n" 
"  AddressU = Clamp;\n" 
"  AddressV = Clamp;\n" 
" }\n" 
" };\n" 
"float4x4    textMatrixArray[NumChannels];\n" 
"struct VS_OUTPUT\n" 
"{\n" 
"	float4 pos : POSITION;					// Screen space position of vertex\n" 
"	float2 PixelPos : COLOR1;				// Pixel position for the alpha mask\n" 
"	float4 texCoordArray[NumChannels] : TEXCOORD0;		// Texture coordinates for each channel\n" 
"};\n" 
"VS_OUTPUT OmniMapVS(float4 vPos : POSITION)\n" 
"{\n" 
"	VS_OUTPUT Output;\n" 
"	float R;\n" 
"	//Output.VertexPosition_WorldSpace = vPos;\n" 
"	\n" 
"	float4x4 tmp = mul(g_mWorldView, g_mProjection);\n" 
"	float4 VertexPosition_projectorSpace_Goal = mul(vPos, tmp);\n" 
"	// F-Theta Warping Code\n" 
"	float Z = VertexPosition_projectorSpace_Goal.z;\n" 
"	float D = length(VertexPosition_projectorSpace_Goal.xyz);\n" 
"	\n" 
"	// Radius at this vertex\n" 
"	R = (2.0/3.14159265) * acos(Z/D);  // Ftheta.\n" 
"	\n" 
"	// Converting the ftheta lenses image to !theta image to account for fisheye lens warping\n" 
"	R =  0.2798*R *R *R *R *R *R  - 0.6875*R *R *R *R *R  + 0.7351*R *R *R *R  - 0.3472*R *R *R  + 0.0977*R *R  + 0.9221*R ;  \n" 
"	float l = 1.0/ (length(VertexPosition_projectorSpace_Goal.xy)+.0000000000000000000000000000000000001);// bug fix  1\n" 
"	\n" 
"	// Direction vector for this vertex, in screen space, from the center of the lens.\n" 
"	float2 thetavec = VertexPosition_projectorSpace_Goal.xy * float2(l,l); \n" 
"	\n" 
"	// Calculate screen pixel coordinates.\n" 
"	Output.pos.xy= thetavec*R;\n" 
"	\n" 
"	// Offset the lens.  Accommodates shifting of the lens vertically.\n" 
"	// In OpenGL, this is done by simply offsetting the viewport, but\n" 
"	// D3D does not like viewports that are off the screen, so we do it here\n" 
"	// in the shader.\n" 
"	Output.pos.y = (Output.pos.y + yOffset1);\n" 
"	Output.pos.y *= yScale;\n" 
"	Output.pos.y = (Output.pos.y + yOffset2);\n" 
"	\n" 
"	Output.pos.w =1.0;\n" 
"	Output.pos.z =D/1000.0;\n" 
"	//Output.VertexPosition_WorldSpace.w = 1.0;\n" 
"	\n" 
"	\n" 
"	// Screen space -> Texture map coordinate for stencil mask.\n" 
"	Output.PixelPos.xy = Output.pos.xy * float2(.5,-.5) + float2(.5 , .5);\n" 
"	// Apply each channel's texture projection matrix to the vertex.\n" 
"	for (int i = 0; i < NumChannels; i++)\n" 
"	{\n" 
"		Output.texCoordArray[i] = mul(vPos, textMatrixArray[i]);	\n" 
"	}\n" 
"		\n" 
"	return(Output);\n" 
"}\n" 
"//--------------------------------------------------------------------------------------\n" 
"// Pixel shader output structure\n" 
"//--------------------------------------------------------------------------------------\n" 
"struct PS_OUTPUT\n" 
"{\n" 
"    float4 RGBColor : COLOR0;  // Pixel color    \n" 
"};\n" 
"PS_OUTPUT OmniMapFS(VS_OUTPUT In)\n" 
"{\n" 
"	PS_OUTPUT Output;\n" 
"	float x,y;\n" 
"	\n" 
"	// Set the fragment color to black in case this position on the\n" 
"	// screen is not intersected by any projected channel\n" 
"	Output.RGBColor = float4(0.0, 0.0, 0.0, 1.0);\n" 
"	for(int i =0; i < NumChannels;i++)	\n" 
"	{\n" 
"		// Calculate the texture coordinate for the i'th channel\n" 
"		// texture\n" 
"		float3 tc;\n" 
"		tc.xy = In.texCoordArray[i].xy / In.texCoordArray[i].w;\n" 
"		tc.y = 1.0f - tc.y;\n" 
"		tc.z = In.texCoordArray[i].w;\n" 
"		\n" 
"		// If the texture coordinate is in the range [0,1] for both u and v, \n" 
"		// and the z value is > 1, this is the channel to use for projecting to\n" 
"		// this fragment.\n" 
"		if (tc.x >= 0.0 && tc.x <= 1.0 && tc.y >= 0.0 && tc.y <= 1.0 && tc.z > 0.0)\n" 
"		{\n" 
"			// Set the output color\n" 
"			Output.RGBColor = float4(MULTISAMPLE_Fin_Fout(Samplers[i], tc.xy).xyz, 1.0);\n" 
"		}\n" 
"	}\n" 
"	\n" 
"	// If the stencil mask is enabled, apply the stencil mask color\n" 
"	// The stencil mask is a screen space mask\n" 
"	if (stencilMaskEnabled)\n" 
"		Output.RGBColor.rgb = Output.RGBColor.rgb * tex2D(alphMaskSampler,In.PixelPos.xy).rgb;\n" 
"	return(Output);\n" 
"}\n" 
"technique RenderScene\n" 
"{\n" 
"    pass P0\n" 
"    {\n" 
"        VertexShader = compile vs_3_0 OmniMapVS();\n" 
"        PixelShader  = compile ps_3_0 OmniMapFS();\n" 
"    }\n" 
"}\n" 
}; 
