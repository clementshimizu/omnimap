// OmniMap Geometry Correction Libs
// (c)2006, 2007, 2010 Elumenati

//#include "Socket.h"  // need socket.cpp socket.h and the lib file
#define MIRROR_BALL 1
#ifdef WIN32
#include <process.h>
#endif
#include <string>
#include <vector>
#include "omnimap.h"
#include <assert.h>
#include <math.h>

#include "gltools/GLShader.h"

#include "Shaders/MirrorVertShader.h"
#include "Shaders/MirrorFragShader.h"

#include "Shaders/VertShader.h"
#include "Shaders/FragShader.h"

#include "Shaders/VertShaderCobra.h"
#include "Shaders/FragShaderCobra.h"

#include "gltools/RenderChannel.h"
#include "privatePrimitives.h"
// JTCHANGE: need defn. of SAVE_AFTER_EVERY_MESSAGE
#include "omnimap_luatable.h"
#include "ScreenRendererOGL.h"

#include "OM_Protector.h"
#include "wwwColorLogo.h"
extern unsigned int logow;
extern unsigned int logoh;
extern char logoDataGL[];

extern bool useSpoutInRenderChannels;
#ifdef USE_DOMEVIEW
#include "../IPC_Domeview/IPCDomeView.h"
static int ApplicationCode;

static HINSTANCE instance = NULL;
static IPCDomeView *domeViewIPC = NULL;
#endif



///////////////////////////////////////////////

#include "omnitypedefs.h"
#include <stdlib.h>



extern OM_ProtectorImpl_Cobra cobtest;
extern std::string preprocessorMacroGlobal;

static const char *fragShaderPrelude = 
"// Start Header: automatically generated by Omnimap\n\
#define MaxChannels %d\n\
float MirrorRadius = %f;\n\
float Grace = %f;\n\
vec3 MirrorCenter = vec3(%f,%f,%f);\n\
vec3 AudiencePosition = vec3(%f,%f,%f);\n\
vec3 ProjectorOrigin= vec3(%f,%f,%f);\n\
vec3 ProjectorRayUp = vec3(%f,%f,%f);\n\
\n%s\n// End Header\n\n";


bool SaveStringList(std::string filename , stringList *List);

/////////////////////////////////////////////////

#include <stdarg.h>
//#ifdef OMNIMAP_EXPORTS
///////////////////

bool OmniMap_ispowerof2(int number);

int OmniMap_getNumberFromGL_TEXTUREID_ARB(int enu);
int OmniMap_getGL_TEXTUREN_ARB_From_N(int n);
//#endif
static GLuint wwwLogoTextureID;

#ifdef _MANAGED
#pragma managed(push, off)
#endif


#ifdef _MANAGED
#pragma managed(pop)
#endif






bool FileExist (char * fileName)
{
   FILE * infile = fopen (fileName, "r");
   if (infile != NULL)
   {
		fclose (infile); // if you don't close, you get in trouble..
		return true;
   }
   return false;
}















int OmniMap_getNumberFromGL_TEXTUREID_ARB(int enu)
{
	switch(enu)
	{
		case GL_TEXTURE0_ARB: return 0;break;
		case GL_TEXTURE1_ARB: return 1;break;
		case GL_TEXTURE2_ARB: return 2;break;
		case GL_TEXTURE3_ARB: return 3;break;
		case GL_TEXTURE4_ARB: return 4;break;
		case GL_TEXTURE5_ARB: return 5;break;
		case GL_TEXTURE6_ARB: return 6;break;
		case GL_TEXTURE7_ARB: return 7;break;
		case GL_TEXTURE8_ARB: return 8;break;
		case GL_TEXTURE9_ARB: return 9;break;
	}

	assert(0 && "Error! getNumberFromGL_TEXTUREID_ARB");
	return 0;

}


int OmniMap_getGL_TEXTUREN_ARB_From_N(int n)
{
	switch(n)
	{
		case 0: return GL_TEXTURE0_ARB;break;
		case 1: return GL_TEXTURE1_ARB;break;
		case 2: return GL_TEXTURE2_ARB;break;
		case 3: return GL_TEXTURE3_ARB;break;
		case 4: return GL_TEXTURE4_ARB;break;
		case 5: return GL_TEXTURE5_ARB;break;
		case 6: return GL_TEXTURE6_ARB;break;
		case 7: return GL_TEXTURE7_ARB;break;
		case 8: return GL_TEXTURE8_ARB;break;
		case 9: return GL_TEXTURE9_ARB;break;
	}
	assert(0 && "Error! getNumberFromGL_TEXTUREID_ARB");
	return GL_TEXTURE0_ARB;
}

void OmniMap_Channel::DrawBox(float x, float y, float size)
{
	glPushAttrib(GL_ALL_ATTRIB_BITS);

    glDisable(GL_ALPHA_TEST);
    glDisable(GL_BLEND);
    glDisable(GL_CULL_FACE);
	glDisable(GL_LIGHTING);
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_CULL_FACE); 
	glMatrixMode(GL_PROJECTION);

	glPushMatrix();
	glLoadIdentity();
	glOrtho(0,1023,0,1023,-1,1);
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();
	glColor4f(1.0,1.0,1.0,1.0);
	glBegin(GL_QUADS);
		glVertex3d(x-size, y-size, 0.0);
		glVertex3d(x-size, y+size, 0.0);
		glVertex3d(x+size, y+size, 0.0);
		glVertex3d(x+size, y-size, 0.0);
	glEnd();
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glPopAttrib();
}


 void OmniMap_Channel::ApplyProjectionMatrix()// assume projection space and identity
{

	glFrustum( cam_info.ClipLeft,
			   cam_info.ClipRight,
		       cam_info.ClipBottom,
		       cam_info.ClipTop,
		       cam_info.ClipNear,
		       cam_info.ClipFar);
}

 void OmniMap_Channel::ApplyViewMatrix() // assume world space
{
	glMultMatrixf(cam_info.Matrix_WorldView);
}



void OmniMap_Channel::SetNearFar(float fnear, float ffar)
{
		float fovy = atan(cam_info.ClipTop/cam_info.ClipNear);
		float aspectRatio = (cam_info.ClipRight - cam_info.ClipLeft) /
							(cam_info.ClipTop - cam_info.ClipBottom);

        cam_info.ClipTop = tan(fovy) * fnear;		
        cam_info.ClipBottom = -cam_info.ClipTop;
        cam_info.ClipLeft   = aspectRatio*cam_info.ClipBottom;
        cam_info.ClipRight  = aspectRatio*cam_info.ClipTop;
		cam_info.ClipNear = fnear;
		cam_info.ClipFar = ffar;
		//RecomputePlaneEquations();
}




////////////////////////////////////////////////////////
//////////////OmniMap_Shader
///////////////////////////////////
OmniMap_Shader::OmniMap_Shader()
{
	StencilMask_TextureID = 0;
	StencilMask_enable = false;
	_glsl_StencilMask = 0;
	
	VertexShaderFilename=0;
	FragmentShaderFilename=0;
	zero();
	initFirstTime();
	
}

OmniMap_Shader::~OmniMap_Shader()
{
	LogSystem()->ReportMessage("OmniMap_OmniMapShader unloading...");

	deinit();
	if(VertexShaderFilename)
		delete [] VertexShaderFilename;
	VertexShaderFilename=0;
	if(FragmentShaderFilename )
		delete []FragmentShaderFilename ;
	FragmentShaderFilename =0;

}



void OmniMap_Shader::reload()
{
	LogSystem()->ReportMessage("OmniMap_OmniMapShader reloading...");
	deinit();
	init();
}
void OmniMap_Shader::init()
{
	char *fragmentShaderSrc;
	char *vertexShaderSrc;
	LogSystem()->ReportMessage("OmniMap_OmniMapShader loading...");
	bool error = false;
	assert(checkGLError() && "Error");



if(CobraWarpWithTrueDimension >0){
			if(   cobtest.IsCobraRegistered() ){
				LogSystem()->ReportError("Elumenati Warp for CobraSimulation enabled.");
			} else{
				LogSystem()->ReportError("CobraWarp features not available, please contact support@elumenati.com to register Omnimap for Cobra Features.");
				CobraWarpWithTrueDimension =0;
			}
		}



	//Create the GLSL program
	OmniMap_ShaderCombo = new GLProgram();

	//Load the Vertex Program

	if (VertexShaderFilename != NULL && FragmentShaderFilename != NULL)
	{
		OmniMap_VertexShader = new GLVertexShader(VertexShaderFilename);
	} else
	{

		int i = 0;
		if (useMirror) {
			vertexShaderSrc = new char[(sizeof(mirror_vs)/sizeof(int))+1];
			for (i = 0; i < sizeof(mirror_vs)/sizeof(int); i++)
			{
				vertexShaderSrc[i] = (char) mirror_vs[i];	

			}
		}else if(1 <= CobraWarpWithTrueDimension ) {
			vertexShaderSrc = new char[(sizeof(vsCobra)/sizeof(int))+1];	
			for (i = 0; i < sizeof(vsCobra)/sizeof(int); i++)
			{
				vertexShaderSrc[i] = (char) vsCobra[i];
			}
		} else {
			vertexShaderSrc = new char[(sizeof(vs)/sizeof(int))+1];	
			for (i = 0; i < sizeof(vs)/sizeof(int); i++)
			{
				vertexShaderSrc[i] = (char) vs[i];
			}
		}
		vertexShaderSrc[i] = (char) 0;

		std::string vertexTotal = preprocessorMacroGlobal + std::string(vertexShaderSrc);

		OmniMap_VertexShader = new GLVertexShader(NULL,vertexTotal.c_str() );
		if(!OmniMap_VertexShader->isCompiled())
		{
			LogSystem()->ReportError("Error:\tVertex Shader did not compile.\n");
			//LogSystem()->ReportError(OmniMap_VertexShader->GetLog().c_str());
		}
		else
		{
			//LogSystem()->ReportMessage(OmniMap_VertexShader->GetLog().c_str());
		}
	}


	//Load the Fragment Program
	if (fragmentPrelude != NULL)
	{	
		if (FragmentShaderFilename != NULL)
		{
			OmniMap_FragmentShader = new GLFragmentShader(FragmentShaderFilename, fragmentPrelude);
		} else
		{	
			int i = 0;
			if (useMirror) {
				fragmentShaderSrc = new char[(sizeof(mirror_fs)/sizeof(int))+1];
				for (i = 0; i < sizeof(mirror_fs)/sizeof(int); i++)
				{
					fragmentShaderSrc[i] = (char) mirror_fs[i];	
				}
			} else if(1 <= CobraWarpWithTrueDimension ){
fragmentShaderSrc = new char[(sizeof(fsCobra)/sizeof(int))+1];
				for (i = 0; i < sizeof(fsCobra)/sizeof(int); i++)
				{
					fragmentShaderSrc[i] = (char) fsCobra[i];	
				}

			} else {
				fragmentShaderSrc = new char[(sizeof(fs)/sizeof(int))+1];
				for (i = 0; i < sizeof(fs)/sizeof(int); i++)
				{
					fragmentShaderSrc[i] = (char) fs[i];
				}
			}

			fragmentShaderSrc[i] = (char) 0;
			char *wholeShaderSrc = new char[strlen(fragmentPrelude) + strlen(fragmentShaderSrc) + 1];
			strcpy(wholeShaderSrc, fragmentPrelude);
			strcat(wholeShaderSrc, fragmentShaderSrc);
			std::string fragTotal = preprocessorMacroGlobal + std::string(wholeShaderSrc);
			OmniMap_FragmentShader = new GLFragmentShader(NULL, fragTotal.c_str());
		}
	} else
	{
		if (FragmentShaderFilename != NULL)
			OmniMap_FragmentShader = new GLFragmentShader(FragmentShaderFilename);
		else
		{

			int i = 0;
			if (useMirror) {
				fragmentShaderSrc = new char[(sizeof(mirror_fs)/sizeof(int))+1];
				for (i = 0; i < sizeof(mirror_fs)/sizeof(int); i++)
				{
					fragmentShaderSrc[i] = (char) mirror_fs[i];	
				}
			} else if(1 <= CobraWarpWithTrueDimension ){
fragmentShaderSrc = new char[(sizeof(fsCobra)/sizeof(int))+1];
				for (i = 0; i < sizeof(fsCobra)/sizeof(int); i++)
				{
					fragmentShaderSrc[i] = (char) fsCobra[i];	
				}

			} else {
				fragmentShaderSrc = new char[(sizeof(fs)/sizeof(int))+1];
				for (i = 0; i < sizeof(fs)/sizeof(int); i++)
				{
					fragmentShaderSrc[i] = (char) fs[i];
				}
			}
			fragmentShaderSrc[i] = (char) 0;
			std::string fragTotal = preprocessorMacroGlobal + std::string(fragmentShaderSrc);
			OmniMap_FragmentShader = new GLFragmentShader(NULL, fragTotal.c_str());
		}
	}
	if(!OmniMap_FragmentShader->isCompiled())
	{
		LogSystem()->ReportError("Error:\tFragment Shader did not compile.\n");
		LogSystem()->ReportError(OmniMap_FragmentShader->GetLog().c_str());

	}
	else
	{
		//LogSystem()->ReportMessage(OmniMap_FragmentShader->GetLog().c_str());
	}

	


	//Link the shaders up to the program
	OmniMap_ShaderCombo->addShader(OmniMap_VertexShader);
	assert(checkGLError() && "Error");
	OmniMap_ShaderCombo->addShader(OmniMap_FragmentShader);
	assert(checkGLError() && "Error");
	OmniMap_ShaderCombo->use();
	assert(checkGLError() && "Error");

	/*
	_glsl_debug1 = OmniMap_ShaderCombo->getUniformVar("debug1");
	if (!_glsl_debug1) {
		LogSystem()->ReportError("Error:\t debug1 not found in shader\n")	;
		error = true;
	}
	*/

	_glsl_StencilMaskEnabled=0;

	if(StencilMask_enable)// if we are using the 
	{
		_glsl_StencilMask= OmniMap_ShaderCombo->getUniformVar("StencilMask");

		if(!_glsl_StencilMask)
		{
			// i will have to fix this... but 
			// here is the idea...
			// finalMask is totally optional...
			// if we dont want it we should have a varible in omnimap we can poll to see if we should even look for it
			// only if we want it should we register it and and check for errors...	
			LogSystem()->ReportError("Error:\t StencilMask not found in shader\n")	;
			error =true;
		}
	} 
	_glsl_StencilMaskEnabled = OmniMap_ShaderCombo->getUniformVar("stencilMaskEnabled");
	/*
	if(!_glsl_StencilMaskEnabled)
	{
		LogSystem()->ReportError("Error:\t stencilMaskEnabled not found in shader\n")	;
		error = true;
	}
	*/


#ifdef notdef
#endif




#ifndef WIN32
	glsl_channelTexture0= OmniMap_ShaderCombo->getUniformVar("channelTextures");
	if(!glsl_channelTexture0 )
	{
		LogSystem()->ReportError("Error:\tglsl_channelTextures not found in shader\n");
		error =true;
	}
#else
	glsl_channelTexture0= OmniMap_ShaderCombo->getUniformVar("channelTexture0");
	if(!glsl_channelTexture0 )
	{
		LogSystem()->ReportError("Error:\tglsl_channelTexture0 not found in shader\n");
		error =true;
	}
	glsl_channelTexture1= OmniMap_ShaderCombo->getUniformVar("channelTexture1");
	if(!glsl_channelTexture1 )
	{
		LogSystem()->ReportError("Error:\tglsl_channelTexture1 not found in shader\n");
		error =true;
	}

	if(CobraWarpWithTrueDimension <= 0 ) {
	glsl_channelTexture2= OmniMap_ShaderCombo->getUniformVar("channelTexture2");
	if(!glsl_channelTexture2 )
	{
	LogSystem()->ReportError("Error:\tglsl_channelTexture2 not found in shader\n");
	error =true;
	}
	glsl_channelTexture3= OmniMap_ShaderCombo->getUniformVar("channelTexture3");
	if(!glsl_channelTexture3 )
	{
	LogSystem()->ReportError("Error:\tglsl_channelTexture2 not found in shader\n");
	error =true;
	}
	}
#endif


	if(1 <= CobraWarpWithTrueDimension ){

		GLUniformVar * glsl_CobraWarpWithTrueDimension= OmniMap_ShaderCombo->getUniformVar  ("CobraWarpWithTrueDimension");
	if(!glsl_CobraWarpWithTrueDimension ) {
		LogSystem()->ReportError("Error:CobraWarpWithTrueDimension not found in shader\n");
		}else{
			glsl_CobraWarpWithTrueDimension->set((float)CobraWarpWithTrueDimension);
		}
		delete glsl_CobraWarpWithTrueDimension;
	}


	assert(checkGLError() && "Error");

	if(error==true)
	{
		LogSystem()->ReportError("error");
		system("pause");
	}

	OmniMap_ShaderCombo->useFixedPipeline();
	LogSystem()->ReportMessage("OmniMap_OmniMapShader done loading...");


}
void OmniMap_Shader::deinit()
{

	OmniMap_ShaderCombo->flagProgramDeletion();
	OmniMap_VertexShader->flagShaderDeletion();
	OmniMap_FragmentShader->flagShaderDeletion();


	delete OmniMap_ShaderCombo;
	delete OmniMap_VertexShader;
	delete OmniMap_FragmentShader;
#ifndef WIN32
	delete glsl_channelTexture0;
#else
	delete glsl_channelTexture0;
	delete glsl_channelTexture1;
	delete glsl_channelTexture2;
	delete glsl_channelTexture3;
#endif

#ifdef notdef
	delete _glsl_StencilMask;
#endif
	zero();
}

void OmniMap_Shader::initFirstTime()
{

	glewInit();
	TestIfShadersAreSupported();
}

bool OmniMap_Shader::TestIfShadersAreSupported()
{
#ifdef __APPLE__
	if(GL_ARB_vertex_shader && GL_ARB_fragment_shader)
#else
	if(GLEW_ARB_vertex_shader && GLEW_ARB_fragment_shader)
#endif
	{
		LogSystem()->ReportMessage(" -- OpenGL Shaders Supported");

	}
	else 
	{
		LogSystem()->ReportError("------------------------------------------------");
		LogSystem()->ReportError("ERROR - OpenGL Shaders Not Supported");
		LogSystem()->ReportError("------------------------------------------------");

		return false;
	}


	//Checking card support for multi-texturing
	GLint num_tex_units, num_tex_frags;
	glGetIntegerv(GL_MAX_TEXTURE_UNITS, &num_tex_units);
	glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS_ARB, &num_tex_frags);
	if (num_tex_units >= 4 && num_tex_frags >= 4)
	{
		LogSystem()->ReportMessage("-- Card supports %d texture units and %d fragment texture units", num_tex_units, num_tex_frags);

	}
	else
	{
		LogSystem()->ReportError("------------------------------------------------");
		LogSystem()->ReportError("ERROR - Card only supports %d texture units and %d fragment texture units", num_tex_units, num_tex_frags);
		LogSystem()->ReportError("------------------------------------------------");
		return false;
	}

	return true;

}


void OmniMap_Shader::zero()
{
	OmniMap_ShaderCombo=0;
	OmniMap_VertexShader=0;
	OmniMap_FragmentShader=0;
#ifndef WIN32
	glsl_channelTexture0=0;
#else
	glsl_channelTexture0=0;
	glsl_channelTexture1=0;
	glsl_channelTexture2=0;
	glsl_channelTexture3=0;
#endif
	_glsl_StencilMask=0;

}

void OmniMap_Shader::EnableShader()
{
	// todo push and pop the previous shader...
	glUseProgramObjectARB(OmniMap_ShaderCombo->getProgramHandle());
}

void OmniMap_Shader::DisableShader()
{
	// todo push and pop the previous shader...
	OmniMap_ShaderCombo->useFixedPipeline();
}

#ifdef ELUMENATI_INTERNAL
GLint OmniMap_Shader::getShaderVarID(const char *name)
{
	return OmniMap_ShaderCombo->getUniformVar(name)->getLocation();
}
#endif

void OmniMap_Shader::SetTextureIds(int numChannels, int *ids)
{
	//glsl_numChannels->set(numChannels);
#ifndef WIN32
	if (glsl_channelTexture0 != 0)
		glsl_channelTexture0->set1v(numChannels,  (const GLint * ) ids);
#else
	for (int i = 0; i < numChannels; i++)
	{
		if (i == 0 && glsl_channelTexture0 != NULL)
			glsl_channelTexture0->set((GLint)ids[0]);
		else if (i == 1 && glsl_channelTexture1 != NULL)
			glsl_channelTexture1->set((GLint)ids[1]);
		else if (i == 2 && glsl_channelTexture2 != NULL)
			glsl_channelTexture2->set((GLint)ids[2]);
		else if (i == 3 && glsl_channelTexture3 != NULL)
			glsl_channelTexture3->set((GLint)ids[3]);
		else if (i == 4 && glsl_channelTexture4 != NULL)
			glsl_channelTexture4->set((GLint)ids[4]);
		else if (i == 5 && glsl_channelTexture5 != NULL)
			glsl_channelTexture5->set((GLint)ids[5]);
	}
#endif
}


///////////////////////////////////////////////////////////
////////OmniMap_Channel
////////////////////////////////////////////////////////////

OmniMap_Channel::OmniMap_Channel()
{
	prc_RenderChannel = NULL;
    useOmniMapMatrix = true;
	xResolution = yResolution = 0;

	renderTarget = OmniMapChannelBase::FRAME_BUFFER_OBJECT;

	SetUpPropertyAccess();
	ConsolidateCameraIntoProjectionMatrix = OMNIMAP_DEFAULT_ConsolidateCameraIntoProjectionMatrix;
}

OmniMap_Channel::~OmniMap_Channel()
{
	LogSystem()->ReportMessage("delete OmniMap_Channel()");
	if (prc_RenderChannel != NULL)
		delete prc_RenderChannel;
}

void OmniMap_Channel::Initialize()
{
		LogSystem()->ReportMessage("OmniMap_Channel::Initialize");

	if (xResolution != 0 && yResolution != 0)
		prc_RenderChannel = new RenderChannel(xResolution, yResolution, (OmniMapChannelBase::TargetType) renderTarget);
	else
		LogSystem()->ReportError("Channel width or height set to 0, width,height = %d,%d\n", xResolution, yResolution);
}

void OmniMap_Channel::SetUpPropertyAccess()
{

    access.Register("UseOmniMapMatrix",&useOmniMapMatrix);

	// register this varible... this should be placed into a better function
	// like a derived SetUpPropertyAccess_Additional()
	access.Register("ConsolidateCameraIntoProjectionMatrix",&ConsolidateCameraIntoProjectionMatrix);
	//OmniMapChannelBase::SetUpPropertyAccess();
}

#ifdef OM_PICKING



void OmniMap_Channel::beginRenderPickingToChannel(int mouseX, int mouseY)
{
	//prc_RenderChannel->beginRenderToChannel();
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();

	int viewport[4];
	glViewport(0,0,32,32);
	glGetIntegerv(GL_VIEWPORT,(GLint *) viewport);
	gluPickMatrix(mouseX,mouseY,
		1024,1024,(GLint *) viewport);
	ApplyProjectionMatrix();
	//gluPerspective(90.0,1.0,0.1,1000);
	ApplyViewMatrix();

	glMatrixMode(GL_MODELVIEW);		// Reset GL_MODELVIEW matrix
	glPushMatrix();
	glLoadIdentity();





}

void OmniMap_Channel::endRenderPickingToChannel()
{
	//if (useOmniMapMatrix)
	    //PopSetupMatricies();
	//prc_RenderChannel->endRenderToChannel();

	glMatrixMode(GL_PROJECTION);		// Reset projection matrix
		glPopMatrix();
		glMatrixMode(GL_MODELVIEW);			// Reset GL_MODELVIEW matrix
		glPopMatrix();

}
#endif

void OmniMap_Channel::beginRenderToChannel()
{
	prc_RenderChannel->beginRenderToChannel();

   

//assert(checkGLError() &&"checkGLError() ");

           

    if (useOmniMapMatrix)
        PushSetupMatricies();

}
void OmniMap_Channel::endRenderToChannel()
{
	
    if (useOmniMapMatrix)
	    PopSetupMatricies();
	prc_RenderChannel->endRenderToChannel();

}



void OmniMap_Channel::PushSetupMatricies()
{

		glMatrixMode(GL_PROJECTION);		// Set GL_PROJECTION matrix
		glPushMatrix();
		glLoadIdentity();
		ApplyProjectionMatrix();
		if(ConsolidateCameraIntoProjectionMatrix)
			ApplyViewMatrix();

		glMatrixMode(GL_MODELVIEW);		// Reset GL_MODELVIEW matrix
		glPushMatrix();
		glLoadIdentity();
		if(!ConsolidateCameraIntoProjectionMatrix)
			ApplyViewMatrix();

}
void OmniMap_Channel::PopSetupMatricies()
{

		glMatrixMode(GL_PROJECTION);		// Reset projection matrix
		glPopMatrix();
		glMatrixMode(GL_MODELVIEW);			// Reset GL_MODELVIEW matrix
		glPopMatrix();

}

	///////////////////////////////////////////////////////////
	////////
	////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////
////////
////////////////////////////////////////////////////////////





void OmniMap::SetUpPropertyAccess()
{
	///////////////
	access.Register("glViewportsettings0",&glViewportsettings0);
	access.Register("glViewportsettings1",&glViewportsettings1);
	access.Register("glViewportsettings2",&glViewportsettings2);
	access.Register("glViewportsettings3",&glViewportsettings3); 
	access.Register("GL_STATE_CLEAR_AT_STARTFRAME",&GL_STATE_CLEAR_AT_STARTFRAME); 
	access.Register("GL_STATE_glDisable_GL_DEPTH_TEST",&GL_STATE_glDisable_GL_DEPTH_TEST); 
	access.Register("GL_STATE_glDepthMask_FALSE",&GL_STATE_glDepthMask_FALSE); 
	access.Register("VertexShaderFile", &vertexShaderFilename[0]);
	access.Register("FragmentShaderFile", &fragmentShaderFilename[0]);
	access.Register("UseMirror", &useMirror);
	access.Register("MirrorRadius", &mirrorRadius);
	access.Register("MirrorGrace", &mirrorGrace);
	access.Register("MirrorCenter_x", &mirrorCenter.x);
	access.Register("MirrorCenter_y", &mirrorCenter.y);
	access.Register("MirrorCenter_z", &mirrorCenter.z);
	access.Register("MirrorProjectorPosition_x", &mirrorProjectorPosition.x);
	access.Register("MirrorProjectorPosition_y", &mirrorProjectorPosition.y);
	access.Register("MirrorProjectorPosition_z", &mirrorProjectorPosition.z);
	access.Register("MirrorProjectorUp_x", &mirrorProjectorUp.x);
	access.Register("MirrorProjectorUp_y", &mirrorProjectorUp.y);
	access.Register("MirrorProjectorUp_z", &mirrorProjectorUp.z);
	
#ifdef USE_DOMEVIEW
	access.Register("ApplicationCode", &ApplicationCode);
#endif
	OmniMapBase::SetUpPropertyAccess();

}


// OMNIMAP INIT
void OmniMap::init()
{
#ifdef USE_DOMEVIEW
	ApplicationCode = 0;
#endif
	std::string setLuaDir = "LuaSupportDir = \"";
	setLuaDir.append(luaSupportDir);
	setLuaDir.append("\"");
	size_t index = 0;
	while ((index = setLuaDir.find("\\", index)) != std::string::npos)
	{
		setLuaDir.replace(index, 1, "/");
		index++;
	}

	bool scriptSuccess = ScriptingEngine->RunString(setLuaDir.c_str());
#ifdef notdef
	if (!scriptSuccess)
	{
		access.SetValue("ErrorCode", 1);
		return;
	}
#endif
	scriptSuccess = ScriptingEngine->RunScript(StartUpScript);
#ifdef notdef
	if (!scriptSuccess)
	{
		access.SetValue("ErrorCode", 2);
		return;
	}
#endif

	assert(checkGLError() && "Error: ScriptingEngine->RunScript(StartUpScript);");

	shaders = new OmniMap_Shader();
	((OmniMap_Shader*)shaders)->CobraWarpWithTrueDimension = (this)->CobraWarpWithTrueDimension;

	assert(checkGLError() && "Error: shaders = new OmniMap_Shader();");

	
	if(CobraWarpWithTrueDimension>0){
		LogSystem()->ReportMessage("CobraWarpWithTrueDimension (0 is off 1 is Warp with TrueDimension On, 2 is Warp with TrueDimension off ) = %d",CobraWarpWithTrueDimension);
	}

	if(StencilMask_filename)
		((OmniMap_Shader *)shaders)->StencilMask_Load(StencilMask_filename); // the final mask needs to be done before the shader is compiled....

	if (vertexShaderFilename[0] != '\0' && fragmentShaderFilename[0] != '\0')
	{
		std::string vertShader = luaSupportDir;
		std::string fragShader = luaSupportDir;
		vertShader.append(vertexShaderFilename);
		fragShader.append(fragmentShaderFilename);
LogSystem()->ReportMessage("loading shader %s",vertShader.c_str());
LogSystem()->ReportMessage("loading shader %s",fragShader.c_str());
		shaders->setShadersFilenames(vertShader.c_str(), fragShader.c_str());
	}

	char prelude[1024];
	if (useMirror) {
		sprintf(prelude, fragShaderPrelude, 
			GetNumChannels(), 
			mirrorRadius,
			mirrorGrace,
			mirrorCenter.x, mirrorCenter.y, mirrorCenter.z,
			AudiencePosition.x, AudiencePosition.y, AudiencePosition.z,
			mirrorProjectorPosition.x, mirrorProjectorPosition.y, mirrorProjectorPosition.z,
			this->mirrorProjectorUp.x, mirrorProjectorUp.y, mirrorProjectorUp.z,
			StencilMask_filename?"#define STENCILMASK_ENABLE":"");
	} else {
		sprintf(prelude, "// Start Header: automatically generated by Omnimap\n#define MaxChannels %d\n%s\n// End Header\n\n", GetNumChannels(),StencilMask_filename?"#define STENCILMASK_ENABLE":"");
	}
	std::string preludeStr = prelude;
	shaders->setShadersPrelude(preludeStr.c_str(), preludeStr.c_str());
	((OmniMap_Shader *) shaders)->setUseMirror(useMirror);
	shaders->init();

	this->LoadBGTexture();

	LogSystem()->ReportMessage("------------OMNIMAP LOADED DOWN----------------");
	LogSystem()->ReportMessage("Use Mirror : %d", useMirror);
	LogSystem()->ReportMessage("glViewportsettings %f %f %f %f",glViewportsettings0,glViewportsettings1,glViewportsettings2,glViewportsettings3);
	LogSystem()->ReportMessage("GL_STATE_CLEAR_AT_STARTFRAME, GL_STATE_glDisable_GL_DEPTH_TEST,GL_STATE_glDepthMask_FALSE %d %d %d",	GL_STATE_CLEAR_AT_STARTFRAME, 
		GL_STATE_glDisable_GL_DEPTH_TEST,GL_STATE_glDepthMask_FALSE );
	LogSystem()->ReportMessage("width %d",		resWidth);
	LogSystem()->ReportMessage("height %d",		resHeight);
	//LogSystem()->ReportMessage("fontname %s",strFont);
	//LogSystem()->ReportMessage("fontsize %f",font_size);
	LogSystem()->ReportMessage("displayHUD  %d",displayHUD );
	LogSystem()->ReportMessage("clear color %f %f %f %f",clearcolor_r,clearcolor_g,clearcolor_b,clearcolor_a );
	LogSystem()->ReportMessage("AudiencePosition %f %f %f\n",AudiencePosition.x,AudiencePosition.y,AudiencePosition.z);
	LogSystem()->ReportMessage("ProjectorPosition.pos %f %f %f\n",ProjectorPosition.pos.x,ProjectorPosition.pos.y,ProjectorPosition.pos.z);
	LogSystem()->ReportMessage("ProjectorPosition.headsUp %f %f %f\n",ProjectorPosition.headsUp.x,ProjectorPosition.headsUp.y,ProjectorPosition.headsUp.z);
	LogSystem()->ReportMessage("ProjectorPosition.lookAtpos %f %f %f\n",ProjectorPosition.lookAtpos.x,ProjectorPosition.lookAtpos.y,ProjectorPosition.lookAtpos.z);
	LogSystem()->ReportMessage("startupscript : %s",StartUpScript);
	LogSystem()->ReportMessage("------------------------------");
#ifdef USE_DOMEVIEW
	instance =0;
	if(FileExist ("IPCDomeView.dll"))
	{
	  instance = LoadLibrary(TEXT("IPCDomeView.dll")); 
      if (instance != NULL) 
	  { 
		IPCDomeViewBuilderFUNC IPCDomeViewBuilder = (IPCDomeViewBuilderFUNC) GetProcAddress(instance, "IPCDomeViewBuilder");
		domeViewIPC = IPCDomeViewBuilder(IPC_DomeViewPlugin_Dummy);
		// SEE MORE DEFINES ON IPCPlugin.h
		LogSystem()->ReportError("-- WARNING USING EXPERIMENTAL DOMEVIEW. Remove IPCDomeView.dll to disable it.");
		if(!domeViewIPC)
			LogSystem()->ReportError("     Loading not successful.");

	  }
	  else
	  {
		LogSystem()->ReportError("-- Could not load IPCDomeView.dll");
	  }
	}

	if(instance==0)
	{
		domeViewIPC=0;
		//    ExitProcess(0);
		LogSystem()->ReportMessage("---------------------------------------------------------------------");
		LogSystem()->ReportMessage("-- NOT USING EXPERIMENTAL DOMEVIEW. ADD IPCDomeView.dll to enable it.");
		LogSystem()->ReportMessage("---------------------------------------------------------------------");
	}
#endif
}




OmniMap::OmniMap(int _resW, int _resH,const char* strStartUpScriptFile, const char *luaResDir, bool doInit) :
	OmniMapBase(_resW, _resH, strStartUpScriptFile, luaResDir)
{
	LogSystem()->ReportMessage("Constructing OmniMap (GL Version)");

	fragmentShaderFilename[0] = '\0';
	vertexShaderFilename[0] = '\0';
	

	glViewportsettings0 = OMNIMAP_DEFAULT_glViewportsettings0;
	glViewportsettings1 = OMNIMAP_DEFAULT_glViewportsettings1;
	glViewportsettings2 = OMNIMAP_DEFAULT_glViewportsettings2;
	glViewportsettings3 = OMNIMAP_DEFAULT_glViewportsettings3;
	GL_STATE_CLEAR_AT_STARTFRAME = OMNIMAP_DEFAULT_GL_STATE_CLEAR_AT_STARTFRAME;
	GL_STATE_glDisable_GL_DEPTH_TEST =OMNIMAP_DEFAULT_GL_STATE_glDisable_GL_DEPTH_TEST;
	GL_STATE_glDepthMask_FALSE = OMNIMAP_DEFAULT_GL_STATE_glDepthMask_FALSE;
	useMirror = false;

	SetUpPropertyAccess();
	glGetError();


	assert(checkGLError() && "error after SetUpPropertyAccess");
	ScreenRendererFactory.addScreenRendererCreator("OGL", &ScreenRendererOGL::CreateScreenRendererOGL);
	if (doInit)
		init();
}


void OmniMap::SetupScriptingCommands()
{


}
OmniMap::~OmniMap()
{
}


OmniMapChannelBase *OmniMap::Create_Channel(const char * name) 
{
	OmniMap_Channel *channel = new OmniMap_Channel();
	return(channel);
}


/*
OmniMap_Screen *OmniMap::Create_ScreenShape(const char * name)
{
	OmniMap_Screen_Dome *p = new OmniMap_Screen_Dome();
	return(p);
}


#ifdef OmniMap_QUAD_UPGRADE
void OmniMap::Create_ScreenShapeQuad(std::string name)
{
	// prevent name conflict
	String_OmniMap_Screen_Map_itor itr = OmniMap_GLOBAL_ScreenShapes.find(name);
	if(itr !=OmniMap_GLOBAL_ScreenShapes.end())
	{
		LogSystem()->ReportError("Error:\t ScreenShape Name Conflict %s!\n",name.c_str());
		delete itr->second;
	}

	OmniMap_GLOBAL_ScreenShapes[name]= new OmniMap_Screen_Quad(); 
}
#endif
*/

void OmniMap::SetupAllShaderVaribles()
{

	int N_Channels;
	int TextureIds[OMNIMAP_maxChannelFaces];
/*
	if (((OmniMap_Shader *) shaders)->_glsl_debug1)
		((OmniMap_Shader *) shaders)->_glsl_debug1->set((GLint) 1);
*/
	GetShaderVariables(N_Channels, (int *) &(TextureIds[0]));
	((OmniMap_Shader *) shaders)->SetTextureIds(N_Channels,TextureIds);


	int texturenonarbnumber = N_Channels+1;
	if(StencilMask_filename)
		((OmniMap_Shader *) shaders)->StencilMask_Bind(texturenonarbnumber);//+1

}

void OmniMap::DrawHeadsUpDisplay()
{
	glDisable(GL_DEPTH_TEST);
	DrawHeadsUpDisplays();
	glEnable(GL_DEPTH_TEST);
}

unsigned int OmniMap_Channel::GetTextureID()
{
	return(prc_RenderChannel->getTextureId());
}

unsigned int OmniMap_Channel::GetFrameBufferID()
{
	return(prc_RenderChannel->getFrameBufferId());
}


void OmniMap_Channel::BindTexture(int index)
{
	glActiveTextureARB(OmniMap_getGL_TEXTUREN_ARB_From_N(index));
	prc_RenderChannel->bindTexture();
}


void OmniMap_Channel::UnbindTexture(int index)
{
	glActiveTextureARB(OmniMap_getGL_TEXTUREN_ARB_From_N(index));
	prc_RenderChannel->unbindTexture();
}


void OmniMap_Channel::DrawHeadsUpDisplay()
{
	
    glDisable(GL_CULL_FACE); 
	glEnable(GL_TEXTURE_2D);
	//glDisable(GL_DEPTH_CLAMP_NV);
	glDisable(GL_STENCIL_TEST);
	glDisable(GL_LIGHTING);
	prc_RenderChannel->bindTexture();

	glColor4f(1.0,1.0,1.0,1.0);
	glBegin(GL_QUADS);
		glTexCoord2f(0.0 ,0.0);
		glVertex3d(HeadsUpDisplay_Quad.bl.x,HeadsUpDisplay_Quad.bl.y,HeadsUpDisplay_Quad.bl.z);
		glTexCoord2f(0 ,1.0);
		glVertex3d(HeadsUpDisplay_Quad.tl.x,HeadsUpDisplay_Quad.tl.y,HeadsUpDisplay_Quad.tl.z);
		glTexCoord2f(1.0 ,1.0);
		glVertex3d(HeadsUpDisplay_Quad.tr.x,HeadsUpDisplay_Quad.tr.y,HeadsUpDisplay_Quad.tr.z);
		glTexCoord2f(1.0 ,0);
		glVertex3d(HeadsUpDisplay_Quad.br.x,HeadsUpDisplay_Quad.br.y,HeadsUpDisplay_Quad.br.z);
	glEnd();
	prc_RenderChannel->unbindTexture();

	glColor4f(.5,.5,.5,1);
	glBegin(GL_LINE_STRIP);
	glVertex3d(HeadsUpDisplay_Quad.bl.x,HeadsUpDisplay_Quad.bl.y,HeadsUpDisplay_Quad.bl.z);
	glVertex3d(HeadsUpDisplay_Quad.tl.x,HeadsUpDisplay_Quad.tl.y,HeadsUpDisplay_Quad.tl.z);
	glVertex3d(HeadsUpDisplay_Quad.tr.x,HeadsUpDisplay_Quad.tr.y,HeadsUpDisplay_Quad.tr.z);
	glVertex3d(HeadsUpDisplay_Quad.br.x,HeadsUpDisplay_Quad.br.y,HeadsUpDisplay_Quad.br.z);
	glEnd();
	glColor4f(1,1,1,1);

}


void OmniMap::LoadAndPush_HUD_Matricies()
{
		glViewport(	0,
				0,
				resWidth,/// aspectratio
				resHeight );
		glMatrixMode(GL_PROJECTION);
		glPushMatrix();
		glLoadIdentity();
		glOrtho(-1,1,-1,1,-1,1);
		glMatrixMode(GL_MODELVIEW);
		glPushMatrix();
		glLoadIdentity();	
		assert(checkGLError() &&"checkGLError() ");	
}

void OmniMap::doGluLookAt()
{
		gluLookAt (
				ProjectorPosition.pos.x,
				ProjectorPosition.pos.y,
				ProjectorPosition.pos.z,
				ProjectorPosition.lookAtpos.x,
				ProjectorPosition.lookAtpos.y,
				ProjectorPosition.lookAtpos.z,
				ProjectorPosition.headsUp.x,
				ProjectorPosition.headsUp.y,
				ProjectorPosition.headsUp.z);

}

void OmniMap_Channel::GetProjectionMatrix(float m[16])
{
	glMatrixMode(GL_TEXTURE);
	glPushMatrix();
	ApplyProjectionMatrix();
	glGetFloatv(GL_TEXTURE_MATRIX, m);
	glPopMatrix();

}

void OmniMap_Channel::GetProjTextMatrix(float m[16])
{
	
	
	glMatrixMode(GL_TEXTURE);
	glPushMatrix();
	glLoadIdentity();
	glTranslatef(.5f, .5f, .5f);
	glScalef(.5f, .5f, .5f);
	ApplyProjectionMatrix();
	ApplyViewMatrix();
	glGetFloatv(GL_TEXTURE_MATRIX, m);
	glPopMatrix();
	
}

void OmniMap::LoadBGTexture()
{
	for (int i = 3; i < 128*128*4; i += 4)
	{
		if (logoDataGL[i] != '\0')
			logoDataGL[i] = '\133';
	}
	glGenTextures(1, (GLuint *) &logoTextureID);
	glBindTexture(GL_TEXTURE_2D, logoTextureID);

	glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, logow,logoh, 0, GL_RGBA, GL_UNSIGNED_BYTE, /*(unsigned char *) */(&logoDataGL[0]));
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);	// Linear Filtering
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);	// Linear Filtering
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	glGenTextures(1, (GLuint *) &wwwLogoTextureID);
	glBindTexture(GL_TEXTURE_2D, wwwLogoTextureID);

	glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, wwwlogow,wwwlogoh, 0, GL_RGB, GL_UNSIGNED_BYTE, 
		(&wwwLogoDataGL[0]));
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);	// Linear Filtering
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);	// Linear Filtering
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	assert(checkGLError() &&"checkGLError() ");	
}

void OmniMap::RenderBG(float x, float y, float w, float h, float r, float s)
{

	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glViewport(	0,
			0,
			resWidth,/// aspectratio
			resHeight );
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	glOrtho(-1,1,-.75,.75,-1,1);
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();

	glDisable(GL_CULL_FACE); 
	glEnable(GL_TEXTURE_2D);
	//glDisable(GL_DEPTH_CLAMP_NV);
	glDisable(GL_STENCIL_TEST);
	glDisable(GL_LIGHTING);
	glBindTexture(GL_TEXTURE_2D, logoTextureID);

	glColor4f(1.0,1.0,1.0,1.0);
	glBegin(GL_QUADS);
	 
		glTexCoord2f(0.0 ,0.0);
		glVertex3d(x,y,0.0);
		glTexCoord2f(0 ,-s);
		glVertex3d(x,y+h,0.0);
		glTexCoord2f(r ,-s);
		glVertex3d(x+w,y+h,0.0);
		glTexCoord2f(r ,0);
		glVertex3d(x+w,y,0.0);

	glEnd();

	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	
	assert(checkGLError() &&"checkGLError() ");	

}


void OmniMap::LoadAndPush_ProjectiveTexturing_Matricies()
{

	assert(checkGLError() &&"checkGLError() ");
	// Load Matricies
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();

	if (glViewportsettings2 <1.0f)
		glViewportsettings2= (float)this->resWidth;
	if(glViewportsettings3<1.0f)
		glViewportsettings3 =(float) this->resHeight;


//	LogSystem()->ReportMessage("glv %f %f %f %f",glViewportsettings0,glViewportsettings1,glViewportsettings2,glViewportsettings3);

		glViewport(glViewportsettings0,
			glViewportsettings1,
			glViewportsettings2,
			glViewportsettings3);


 	glOrtho(-1.0f,1.0f,-1.0f,1.0f,-1.0f,1.0f);
	assert(checkGLError() &&"checkGLError() ");

	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();
	doGluLookAt();

	
	//for (int i = 0; i < this->GetNumChannels(); i++)
	for (int i = this->GetNumChannels()-1; i >= 0; i--)
	{
	
		OmniMapChannelBase *channel = this->GetChannel(i);
		glActiveTextureARB(OmniMap_getGL_TEXTUREN_ARB_From_N(i)); 
		channel->BindTexture(i);
		glMatrixMode(GL_TEXTURE);
		glPushMatrix();
		glLoadIdentity();
		glTranslatef(.5f, .5f, .5f);

		glScalef(.5f, .5f, .5f);
	
		channel->ApplyProjectionMatrix();
	
		channel->ApplyViewMatrix();
		
		glMatrixMode(GL_MODELVIEW);
		assert(checkGLError() &&"checkGLError() ");
	}
	

  }

void OmniMap::PopMatricies()
{
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
}


void OmniMap::Clear()
{
	glClearColor(clearcolor_r,clearcolor_g,clearcolor_b,clearcolor_a); 
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	 
}
void OmniMap::PostRender()
{
	glPushAttrib(GL_ALL_ATTRIB_BITS);

    glDisable(GL_ALPHA_TEST);
    glDisable(GL_BLEND);
    glDisable(GL_CULL_FACE);
	glDisable(GL_LIGHTING);
	glDisable(GL_DEPTH_TEST);
	


	//glEnable(GL_TEXTURE_RECTANGLE_ARB);
	glEnable(GL_TEXTURE_2D);
	//glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR); 
	//glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR); 

	// Post Render does a few things
	// A0 Clear
	// B1 set the projective shader
	// B2 Set up Shaders 
	// B3 textures
	// B4 Set up matricies
	// C1 Display Screen
	// D0 disable shaders
	// D1 Disable Textures
	// D2 Set active texutre to 0

	// E0 PushAndSetupMatrix
	// E1 draw lua console
	// E2 draw heads up display
	// E7 PopMatrix
	//  8 

	// A. 0 Clear
	if(GL_STATE_CLEAR_AT_STARTFRAME)
		Clear();

	// B.1 set the projective shader
	shaders->EnableShader();

	// B.2  set the textures
	BindAllChannelTextures();

	// B.3 Shader Parameters
	SetupAllShaderVaribles();

	// B.4 Set up matricies
	LoadAndPush_ProjectiveTexturing_Matricies();

	if(GL_STATE_glDisable_GL_DEPTH_TEST)
		glDisable(GL_DEPTH_TEST);
	if(GL_STATE_glDepthMask_FALSE)
		glDepthMask(false);
	// C.1 Display World

	DisplayScreenShapes();
	for (int i = 0; i < this->GetNumChannels(); i++)
	{
		OmniMapChannelBase *channel = this->GetChannel(i);
		glActiveTextureARB(OmniMap_getGL_TEXTUREN_ARB_From_N(i));
		channel->BindTexture(i);
		glMatrixMode(GL_TEXTURE);
		glPopMatrix();
	}

	PopMatricies();

	// D0 disable shaders
	shaders->DisableShader(); // use fixed pipeline

	// D1 Disable Textures
	UnBindAllChannelTextures();


	// D2 Set ARB0
	// this might be wrong
	glActiveTextureARB(OmniMap_getGL_TEXTUREN_ARB_From_N(0));

	// E0 PushAndSetupMatrix
	LoadAndPush_HUD_Matricies();

	// E1 draw lua console
		//		if(console->display_Console)
		//		  console->DisplayConsole();
	// E2 Draw HUD

	if(displayHUD)
		DrawHeadsUpDisplay();

	if(GL_STATE_glDisable_GL_DEPTH_TEST)
		glEnable(GL_DEPTH_TEST);
	if(GL_STATE_glDepthMask_FALSE)
		glDepthMask(true);
	// E7 PopMatrix
	PopMatricies();
		
	
	assert(checkGLError() &&"checkGLError() ");

	if (om_protector.isProtected())
	{
		RenderBG(-.15f, -.7f, .3f, .3f, 1.0f, 1.0f);
		unsigned int savetid = this->logoTextureID;
		this->logoTextureID = wwwLogoTextureID;
		if (glViewportsettings1 < 0.0)
			RenderBG(-1.0f, .55f, .2f, .2f, 1.0f, 1.0f);
		else
			RenderBG(-1.0f, -.75f, .2f, .2f, 1.0f, 1.0f);
		this->logoTextureID = savetid;
	}

	glPopAttrib();


#ifdef USE_DOMEVIEW
 /*
	if (domeViewIPC == NULL && ApplicationCode != 0)
	{
		domeViewIPC = new IPCDomeView(IPC_DomeViewPlugin_OmniMapFlag | ApplicationCode);	
	}
		*/ 
	if (domeViewIPC)
	{
		if (domeViewIPC->isFree(this->resWidth, this->resHeight, Format_RGB)) {
			//domeViewIPC->pluginIPC->setParamsFilled(PARAMS_EMPTY);
			//domeViewIPC->pluginIPC->setProjection(PROJECTION_AzimuthalEquidistant);
			//domeViewIPC->pluginIPC->setMirror(MIRROR_X);
			//domeViewIPC->pluginIPC->setAlt(90.0);
			//domeViewIPC->pluginIPC->setAzi(0.0);
			//domeViewIPC->pluginIPC->setRotation(0);
			//domeViewIPC->pluginIPC->setAngularWidth(180.0);
			//domeViewIPC->pluginIPC->setAngularHeight(135.0);
			void *pixel = domeViewIPC->getBuffer();
			glReadPixels(0, 0, this->resWidth, this->resHeight, GL_RGB, GL_UNSIGNED_BYTE, pixel);
			domeViewIPC->done();
		}
	}


#endif
	/// SPOUT
	if(useSpoutInRenderChannels){
		for (int i = 0; i < this->GetNumChannels(); i++)
		{
			OmniMap_Channel *c= (OmniMap_Channel *)this->GetChannel(i);
			if(c!=0){
				RenderChannel *channel = c->prc_RenderChannel;
				if(channel!=0){
					channel->UpdateSpout();
				}
			}
		}
	}
}



 void OmniMap_Shader::StencilMask_Free()
{
	// delete glid
	if(StencilMask_TextureID>0)	
		glDeleteTextures(1,(const GLuint *) &StencilMask_TextureID);
	StencilMask_TextureID=0;
	StencilMask_enable = false;
}
	
 void OmniMap_Shader::StencilMask_Load(char *StencilMask_FileName)	
{
		if(StencilMask_TextureID>0)
		{
			StencilMask_Free();
		}

		StencilMask_enable = true;

		BaseImage mask(StencilMask_FileName);
		// load to opengl...
		// make sure to remember to dele the stuff	
		// bitmap->load(FinalMaskFileName)

		

		glGenTextures(1,(GLuint *) &StencilMask_TextureID);
		glBindTexture(GL_TEXTURE_2D, StencilMask_TextureID);

		if(mask.hasAlpha){
			glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, mask.w,mask.h, 0, GL_RGBA, GL_UNSIGNED_BYTE, mask.bytes);
		}else{
			glTexImage2D (GL_TEXTURE_2D, 0, GL_RGB, mask.w,mask.h, 0, GL_RGB, GL_UNSIGNED_BYTE, mask.bytes);
		}
		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);	// Linear Filtering
		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);	// Linear Filtering
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	

		assert(checkGLError() && "error loading image");

}


 void OmniMap_Shader::StencilMask_Bind(int texture_number_not_arb)
{
	// load the 

	int number = texture_number_not_arb;
	if (number > 0)
	{
		GLint id =OmniMap_getGL_TEXTUREN_ARB_From_N(number);
		glActiveTextureARB(id);
		glBindTexture(GL_TEXTURE_2D, StencilMask_TextureID);
		GLint idNumber = number;

		if(!_glsl_StencilMask)
		{
			_glsl_StencilMask= OmniMap_ShaderCombo->getUniformVar("StencilMask");
		}

		
		_glsl_StencilMask->set1v(1,&idNumber);

		if(_glsl_StencilMaskEnabled!=NULL){
			_glsl_StencilMaskEnabled->set((GLint) 1);
		}

	} else
	{
		if(_glsl_StencilMaskEnabled!=NULL){
			_glsl_StencilMaskEnabled->set((GLint) 0);
		}
	}
	
//		_glsl_StencilMask->set( (GLint) StencilMask_TextureID  );
}


//	 void OmniMap_Shader::SetUpPropertyAccess()
//	{
//		LogSystem()->ReportError("OmniMap_Shader::SetUpPropertyAccess()");
//		access.Register("useFinalMask", &useFinalMask); 
		// i would like to register FinalMaskFileName... but i cant because we need to use it b4 we 
//////// something like this		access.Register("",FinalMaskFileName

//	}



